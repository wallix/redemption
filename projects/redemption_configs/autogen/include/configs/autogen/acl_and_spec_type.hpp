// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
// 

#pragma once

#include "configs/autogen/variables_configuration_fwd.hpp"

namespace configs {
template<class Cfg> struct acl_and_spec_type {};

template<> struct acl_and_spec_type<cfg::globals::front_connection_time> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::globals::target_connection_time> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::globals::auth_user> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::host> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::target> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::target_device> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::device_id> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::primary_user_id> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::target_user> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::target_application> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::target_application_account> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::target_application_password> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::port> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::globals::authfile> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::globals::handshake_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::globals::base_inactivity_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::globals::inactivity_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::globals::keepalive_grace_delay> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::globals::authentication_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::globals::trace_type> { using type = TraceType; };
template<> struct acl_and_spec_type<cfg::globals::listen_address> { using type = ::configs::spec_types::ip; };
template<> struct acl_and_spec_type<cfg::globals::enable_transparent_mode> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::certificate_password> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::globals::is_rec> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::enable_bitmap_update> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::enable_end_time_warning_osd> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::enable_osd_display_remote_target> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::show_target_user_in_f12_message> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::enable_wab_integration> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::large_pointer_support> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::mod_recv_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 100, 10000>; };
template<> struct acl_and_spec_type<cfg::globals::experimental_enable_serializer_data_block_size_limit> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::rdp_keepalive_connection_interval> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::globals::enable_ipv6> { using type = bool; };
template<> struct acl_and_spec_type<cfg::globals::minimal_memory_available_before_connection_silently_closed> { using type = uint64_t; };
template<> struct acl_and_spec_type<cfg::client::keyboard_layout> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::client::ignore_logon_password> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::allow_using_multiple_monitors> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::allow_scale_factor> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::unicode_keyboard_event_support> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::encryption_level> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::client::tls_fallback_legacy> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::tls_support> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::tls_min_level> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::client::tls_max_level> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::client::show_common_cipher_list> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::ssl_cipher_list> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::client::enable_nla> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::disable_tsk_switch_shortcuts> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::rdp_compression> { using type = RdpCompression; };
template<> struct acl_and_spec_type<cfg::client::max_color_depth> { using type = ColorDepth; };
template<> struct acl_and_spec_type<cfg::client::persistent_disk_bitmap_cache> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::cache_waiting_list> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::persist_bitmap_cache_on_disk> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::bitmap_compression> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::fast_path> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::enable_suppress_output> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::bogus_ios_glyph_support_level> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::transform_glyph_to_bitmap> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::recv_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 100, 10000>; };
template<> struct acl_and_spec_type<cfg::client::enable_osd_4_eyes> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::enable_remotefx> { using type = bool; };
template<> struct acl_and_spec_type<cfg::client::disabled_orders> { using type = ::configs::spec_types::list<unsigned>; };
template<> struct acl_and_spec_type<cfg::all_target_mod::connection_establishment_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 1000, 10000>; };
template<> struct acl_and_spec_type<cfg::all_target_mod::tcp_user_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 3600000>; };
template<> struct acl_and_spec_type<cfg::remote_program::allow_resize_hosted_desktop> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::force_performance_flags> { using type = RdpPerformanceFlags; };
template<> struct acl_and_spec_type<cfg::mod_rdp::auto_adjust_performance_flags> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::rdp_compression> { using type = RdpCompression; };
template<> struct acl_and_spec_type<cfg::mod_rdp::disconnect_on_logon_user_change> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::open_session_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::mod_rdp::disabled_orders> { using type = ::configs::spec_types::list<unsigned>; };
template<> struct acl_and_spec_type<cfg::mod_rdp::enable_nla> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::enable_kerberos> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::tls_min_level> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::mod_rdp::tls_max_level> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::mod_rdp::tls_security_level> { using type = int; };
template<> struct acl_and_spec_type<cfg::mod_rdp::cipher_string> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::show_common_cipher_list> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::persistent_disk_bitmap_cache> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::cache_waiting_list> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::persist_bitmap_cache_on_disk> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::allowed_channels> { using type = ::configs::spec_types::list<std::string>; };
template<> struct acl_and_spec_type<cfg::mod_rdp::denied_channels> { using type = ::configs::spec_types::list<std::string>; };
template<> struct acl_and_spec_type<cfg::mod_rdp::allowed_dynamic_channels> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::denied_dynamic_channels> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::fast_path> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::server_redirection_support> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::load_balance_info> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::client_address_sent> { using type = ClientAddressSent; };
template<> struct acl_and_spec_type<cfg::mod_rdp::proxy_managed_drives> { using type = ::configs::spec_types::list<std::string>; };
template<> struct acl_and_spec_type<cfg::mod_rdp::ignore_auth_channel> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::auth_channel> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::checkout_channel> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::alternate_shell> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::shell_arguments> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::shell_working_directory> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::use_client_provided_alternate_shell> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::use_client_provided_remoteapp> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::use_native_remoteapp_capability> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::application_driver_exe_or_file> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::application_driver_script_argument> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::application_driver_chrome_dt_script> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::application_driver_chrome_uia_script> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::application_driver_firefox_uia_script> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::application_driver_ie_script> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::hide_client_name> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::use_license_store> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::bogus_ios_rdpdr_virtual_channel> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::bogus_refresh_rect> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::enable_rdpdr_data_analysis> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::remoteapp_bypass_legal_notice_delay> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::mod_rdp::remoteapp_bypass_legal_notice_timeout> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::mod_rdp::log_only_relevant_clipboard_activities> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::split_domain> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::wabam_uses_translated_remoteapp> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::session_shadowing_support> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::enable_remotefx> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::enable_restricted_admin_mode> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::force_smartcard_authentication> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::enable_ipv6> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::mode_console> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::auto_reconnection_on_losing_target_link> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::allow_session_reconnection_by_shortcut> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::session_reconnection_delay> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 15000>; };
template<> struct acl_and_spec_type<cfg::mod_rdp::forward_client_build_number> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::bogus_monitor_layout_treatment> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::effective_krb_armoring_user> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::effective_krb_armoring_password> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_rdp::remote_programs_disconnect_message_delay> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 3000, 120000>; };
template<> struct acl_and_spec_type<cfg::mod_rdp::use_session_probe_to_launch_remote_program> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_rdp::replace_null_pointer_by_default_pointer> { using type = bool; };
template<> struct acl_and_spec_type<cfg::protocol::save_session_info_pdu> { using type = RdpSaveSessionInfoPDU; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_session_probe> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::exe_or_file> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::session_probe::arguments> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::session_probe::use_smart_launcher> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_launch_mask> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::on_launch_failure> { using type = SessionProbeOnLaunchFailure; };
template<> struct acl_and_spec_type<cfg::session_probe::launch_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>; };
template<> struct acl_and_spec_type<cfg::session_probe::launch_fallback_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>; };
template<> struct acl_and_spec_type<cfg::session_probe::start_launch_timeout_timer_only_after_logon> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::keepalive_timeout> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 60000>; };
template<> struct acl_and_spec_type<cfg::session_probe::on_keepalive_timeout> { using type = SessionProbeOnKeepaliveTimeout; };
template<> struct acl_and_spec_type<cfg::session_probe::end_disconnected_session> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_autodeployed_appdriver_affinity> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_log> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_log_rotation> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::log_level> { using type = SessionProbeLogLevel; };
template<> struct acl_and_spec_type<cfg::session_probe::disconnected_application_limit> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>; };
template<> struct acl_and_spec_type<cfg::session_probe::disconnected_session_limit> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>; };
template<> struct acl_and_spec_type<cfg::session_probe::idle_session_limit> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>; };
template<> struct acl_and_spec_type<cfg::session_probe::smart_launcher_clipboard_initialization_delay> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::session_probe::smart_launcher_start_delay> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::session_probe::smart_launcher_long_delay> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::session_probe::smart_launcher_short_delay> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::session_probe::smart_launcher_enable_wabam_affinity> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::launcher_abort_delay> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_crash_dump> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::handle_usage_limit> { using type = ::configs::spec_types::range<uint32_t, 0, 1000>; };
template<> struct acl_and_spec_type<cfg::session_probe::memory_usage_limit> { using type = ::configs::spec_types::range<uint32_t, 0, 200000000>; };
template<> struct acl_and_spec_type<cfg::session_probe::cpu_usage_alarm_threshold> { using type = ::configs::spec_types::range<uint32_t, 0, 10000>; };
template<> struct acl_and_spec_type<cfg::session_probe::cpu_usage_alarm_action> { using type = SessionProbeCPUUsageAlarmAction; };
template<> struct acl_and_spec_type<cfg::session_probe::end_of_session_check_delay_time> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 60000>; };
template<> struct acl_and_spec_type<cfg::session_probe::ignore_ui_less_processes_during_end_of_session_check> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::extra_system_processes> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::session_probe::childless_window_as_unidentified_input_field> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::windows_of_these_applications_as_unidentified_input_field> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::session_probe::update_disabled_features> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::disabled_features> { using type = SessionProbeDisabledFeature; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_bestsafe_interaction> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::on_account_manipulation> { using type = SessionProbeOnAccountManipulation; };
template<> struct acl_and_spec_type<cfg::session_probe::alternate_directory_environment_variable> { using type = ::configs::spec_types::fixed_string; };
template<> struct acl_and_spec_type<cfg::session_probe::public_session> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::outbound_connection_monitoring_rules> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::session_probe::process_monitoring_rules> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::session_probe::customize_executable_name> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::allow_multiple_handshake> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::at_end_of_session_freeze_connection_and_wait> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::enable_cleaner> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::clipboard_based_launcher_reset_keyboard_status> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_probe::process_command_line_retrieve_method> { using type = SessionProbeProcessCommandLineRetrieveMethod; };
template<> struct acl_and_spec_type<cfg::session_probe::periodic_task_run_interval> { using type = ::configs::spec_types::range<std::chrono::milliseconds, 300, 2000>; };
template<> struct acl_and_spec_type<cfg::session_probe::pause_if_session_is_disconnected> { using type = bool; };
template<> struct acl_and_spec_type<cfg::server_cert::server_cert_store> { using type = bool; };
template<> struct acl_and_spec_type<cfg::server_cert::server_cert_check> { using type = ServerCertCheck; };
template<> struct acl_and_spec_type<cfg::server_cert::server_access_allowed_message> { using type = ServerNotification; };
template<> struct acl_and_spec_type<cfg::server_cert::server_cert_create_message> { using type = ServerNotification; };
template<> struct acl_and_spec_type<cfg::server_cert::server_cert_success_message> { using type = ServerNotification; };
template<> struct acl_and_spec_type<cfg::server_cert::server_cert_failure_message> { using type = ServerNotification; };
template<> struct acl_and_spec_type<cfg::server_cert::error_message> { using type = ServerNotification; };
template<> struct acl_and_spec_type<cfg::server_cert::enable_external_validation> { using type = bool; };
template<> struct acl_and_spec_type<cfg::server_cert::external_cert> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::server_cert::external_response> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_vnc::clipboard_up> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_vnc::clipboard_down> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_vnc::encodings> { using type = ::configs::spec_types::list<int>; };
template<> struct acl_and_spec_type<cfg::mod_vnc::support_cursor_pseudo_encoding> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_vnc::server_clipboard_encoding_type> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::mod_vnc::bogus_clipboard_infinite_loop> { using type = VncBogusClipboardInfiniteLoop; };
template<> struct acl_and_spec_type<cfg::mod_vnc::server_is_macos> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_vnc::server_unix_alt> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_vnc::enable_ipv6> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_log::enable_session_log_file> { using type = bool; };
template<> struct acl_and_spec_type<cfg::session_log::enable_syslog_format> { using type = SessionLogFormat; };
template<> struct acl_and_spec_type<cfg::session_log::keyboard_input_masking_level> { using type = KeyboardInputMaskingLevel; };
template<> struct acl_and_spec_type<cfg::ocr::version> { using type = OcrVersion; };
template<> struct acl_and_spec_type<cfg::ocr::locale> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::ocr::interval> { using type = std::chrono::duration<unsigned, std::ratio<1, 100>>; };
template<> struct acl_and_spec_type<cfg::ocr::on_title_bar_only> { using type = bool; };
template<> struct acl_and_spec_type<cfg::ocr::max_unrecog_char_rate> { using type = ::configs::spec_types::range<unsigned, 0, 100>; };
template<> struct acl_and_spec_type<cfg::capture::record_filebase> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::capture::record_subdirectory> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::capture::fdx_path> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::capture::disable_keyboard_log> { using type = KeyboardLogFlags; };
template<> struct acl_and_spec_type<cfg::video::capture_flags> { using type = CaptureFlags; };
template<> struct acl_and_spec_type<cfg::video::png_interval> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::video::break_interval> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::video::png_limit> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::video::hash_path> { using type = ::configs::spec_types::directory_path; };
template<> struct acl_and_spec_type<cfg::video::record_tmp_path> { using type = ::configs::spec_types::directory_path; };
template<> struct acl_and_spec_type<cfg::video::record_path> { using type = ::configs::spec_types::directory_path; };
template<> struct acl_and_spec_type<cfg::video::enable_keyboard_log> { using type = bool; };
template<> struct acl_and_spec_type<cfg::video::disable_clipboard_log> { using type = ClipboardLogFlags; };
template<> struct acl_and_spec_type<cfg::video::disable_file_system_log> { using type = FileSystemLogFlags; };
template<> struct acl_and_spec_type<cfg::video::wrm_color_depth_selection_strategy> { using type = ColorDepthSelectionStrategy; };
template<> struct acl_and_spec_type<cfg::video::wrm_compression_algorithm> { using type = WrmCompressionAlgorithm; };
template<> struct acl_and_spec_type<cfg::video::codec_id> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::video::framerate> { using type = ::configs::spec_types::range<unsigned, 1, 120>; };
template<> struct acl_and_spec_type<cfg::video::ffmpeg_options> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::video::notimestamp> { using type = bool; };
template<> struct acl_and_spec_type<cfg::video::smart_video_cropping> { using type = SmartVideoCropping; };
template<> struct acl_and_spec_type<cfg::video::play_video_with_corrupted_bitmap> { using type = bool; };
template<> struct acl_and_spec_type<cfg::video::allow_rt_without_recording> { using type = bool; };
template<> struct acl_and_spec_type<cfg::video::file_permissions> { using type = FilePermissions; };
template<> struct acl_and_spec_type<cfg::audit::rt_display> { using type = bool; };
template<> struct acl_and_spec_type<cfg::audit::use_redis> { using type = bool; };
template<> struct acl_and_spec_type<cfg::audit::redis_timeout> { using type = std::chrono::milliseconds; };
template<> struct acl_and_spec_type<cfg::audit::redis_address> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::audit::redis_port> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::audit::redis_password> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::audit::redis_db> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::audit::redis_use_tls> { using type = bool; };
template<> struct acl_and_spec_type<cfg::audit::redis_tls_cacert> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::audit::redis_tls_cert> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::audit::redis_tls_key> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::file_verification::socket_path> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::file_verification::enable_up> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::enable_down> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::clipboard_text_up> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::clipboard_text_down> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::block_invalid_file_up> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::block_invalid_file_down> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::block_invalid_clipboard_text_up> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::block_invalid_clipboard_text_down> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::log_if_accepted> { using type = bool; };
template<> struct acl_and_spec_type<cfg::file_verification::max_file_size_rejected> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::file_verification::tmpdir> { using type = ::configs::spec_types::directory_path; };
template<> struct acl_and_spec_type<cfg::file_storage::store_file> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::crypto::encryption_key> { using type = ::configs::spec_types::fixed_binary; };
template<> struct acl_and_spec_type<cfg::crypto::sign_key> { using type = ::configs::spec_types::fixed_binary; };
template<> struct acl_and_spec_type<cfg::websocket::enable_websocket> { using type = bool; };
template<> struct acl_and_spec_type<cfg::websocket::use_tls> { using type = bool; };
template<> struct acl_and_spec_type<cfg::websocket::listen_address> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::psid> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::opt_bpp> { using type = ColorDepth; };
template<> struct acl_and_spec_type<cfg::context::opt_height> { using type = uint16_t; };
template<> struct acl_and_spec_type<cfg::context::opt_width> { using type = uint16_t; };
template<> struct acl_and_spec_type<cfg::context::selector> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::selector_current_page> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::context::selector_device_filter> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::selector_group_filter> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::selector_proto_filter> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::selector_lines_per_page> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::context::selector_number_of_pages> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::context::target_password> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::target_host> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::tunneling_target_host> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::target_str> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::target_service> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::target_port> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::context::target_protocol> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::password> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::reporting> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_channel_answer> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_channel_target> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::display_link> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::mod_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::context::accept_message> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::display_message> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::rejected> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::keepalive> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::session_id> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::end_date_cnx> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::context::real_target_device> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::authentication_challenge> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::ticket> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::comment> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::duration> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::duration_max> { using type = std::chrono::minutes; };
template<> struct acl_and_spec_type<cfg::context::waitinforeturn> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::showform> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::formflag> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::context::module> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::try_alternate_target> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::has_more_target> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::proxy_opt> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::pattern_kill> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::pattern_notify> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::opt_message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::login_message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::disconnect_reason> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::disconnect_reason_ack> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::recording_started> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::rt_ready> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::sharing_ready> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::auth_command> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_notify> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_notify_rail_exec_flags> { using type = unsigned; };
template<> struct acl_and_spec_type<cfg::context::auth_notify_rail_exec_exe_or_file> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_exec_result> { using type = uint16_t; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_flags> { using type = uint16_t; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_original_exe_or_file> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_exe_or_file> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_working_dir> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_arguments> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_account> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::auth_command_rail_exec_password> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::session_probe_launch_error_message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::is_wabam> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::pm_response> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::pm_request> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::native_session_id> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_available> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_userdata> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_type> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_invitation_error_code> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_invitation_error_message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_invitation_id> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_invitation_addr> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::rd_shadow_invitation_port> { using type = uint16_t; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_userdata> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_enable_control> { using type = bool; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_ttl> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_invitation_error_code> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_invitation_error_message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_invitation_id> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_invitation_addr> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_target_ip> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::session_sharing_target_login> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::smartcard_login> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::banner_message> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::context::banner_type> { using type = BannerType; };
template<> struct acl_and_spec_type<cfg::internal_mod::enable_target_field> { using type = bool; };
template<> struct acl_and_spec_type<cfg::internal_mod::keyboard_layout_proposals> { using type = ::configs::spec_types::list<std::string>; };
template<> struct acl_and_spec_type<cfg::internal_mod::enable_close_box> { using type = bool; };
template<> struct acl_and_spec_type<cfg::internal_mod::close_box_timeout> { using type = std::chrono::seconds; };
template<> struct acl_and_spec_type<cfg::mod_replay::replay_path> { using type = ::configs::spec_types::directory_path; };
template<> struct acl_and_spec_type<cfg::mod_replay::on_end_of_data> { using type = bool; };
template<> struct acl_and_spec_type<cfg::mod_replay::replay_on_loop> { using type = bool; };
template<> struct acl_and_spec_type<cfg::translation::language> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::translation::login_language> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::theme::enable_theme> { using type = bool; };
template<> struct acl_and_spec_type<cfg::theme::logo_path> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::theme::bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::separator_color> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::focus_color> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::error_color> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::edit_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::edit_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::edit_focus_color> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::tooltip_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::tooltip_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::tooltip_border_color> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_line1_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_line1_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_line2_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_line2_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_focus_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_focus_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_selected_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_selected_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_label_bgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::theme::selector_label_fgcolor> { using type = ::configs::spec_types::rgb; };
template<> struct acl_and_spec_type<cfg::debug::fake_target_ip> { using type = std::string; };
template<> struct acl_and_spec_type<cfg::debug::capture> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::auth> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::session> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::front> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::mod_rdp> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::mod_vnc> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::mod_internal> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::sck_mod> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::sck_front> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::password> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::compression> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::cache> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::ocr> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::ffmpeg> { using type = uint32_t; };
template<> struct acl_and_spec_type<cfg::debug::config> { using type = bool; };
template<> struct acl_and_spec_type<cfg::debug::mod_rdp_use_failure_simulation_socket_transport> { using type = ModRdpUseFailureSimulationSocketTransport; };
template<> struct acl_and_spec_type<cfg::debug::probe_client_addresses> { using type = ::configs::spec_types::list<std::string>; };

}
