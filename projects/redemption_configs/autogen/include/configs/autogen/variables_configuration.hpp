//
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN
//

namespace cfg {
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::capture_chunk {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "capture_chunk";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(0);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: nla_login <br/>
    /// value{} <br/>
    struct globals::nla_auth_user {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "nla_auth_user";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(1);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: login <br/>
    /// value{} <br/>
    struct globals::auth_user {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "auth_user";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(2);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: ip_client <br/>
    /// value{} <br/>
    struct globals::host {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "host";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(3);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: ip_target <br/>
    /// value{} <br/>
    struct globals::target {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(4);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::target_device {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_device";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(5);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::device_id {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "device_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(6);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::primary_user_id {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "primary_user_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(7);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: target_login <br/>
    /// value{} <br/>
    struct globals::target_user {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_user";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(8);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::target_application {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_application";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(9);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::target_application_account {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_application_account";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(10);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct globals::target_application_password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "target_application_password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(11);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::glyph_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "glyph_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Warning: Service will be automatically restarted and active sessions will be disconnected <br/>
    /// The port set in this field must not be already used, otherwise the service will not run. <br/>
    /// type: unsigned int <br/>
    /// value{3389} <br/>
    struct globals::port {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "port";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{3389};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::nomouse {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "nomouse";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: Level <br/>
    /// value = static_cast<type>(0) <br/>
    struct globals::encryptionLevel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "encryptionLevel";
        using type = Level;
        using sesman_and_spec_type = Level;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::string <br/>
    /// value = REDEMPTION_CONFIG_AUTHFILE <br/>
    struct globals::authfile {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "authfile";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_AUTHFILE;
    };
    /// Time out during RDP handshake stage. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{10} <br/>
    struct globals::handshake_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "handshake_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{10};
    };
    /// No traffic auto disconnection. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{900} <br/>
    struct globals::session_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "session_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{900};
    };
    /// No traffic auto disconnection. <br/>
    /// If value is 0, global value (session_timeout) is used. <br/>
    /// type: std::chrono::seconds <br/>
    /// connpolicy -> proxy    [name: session::inactivity_timeout] <br/>
    /// sesman::name: globals:inactivity_timeout <br/>
    /// value{0} <br/>
    struct globals::inactivity_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "inactivity_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(12);
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Keepalive. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{30} <br/>
    struct globals::keepalive_grace_delay {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "keepalive_grace_delay";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{30};
    };
    /// Specifies the time to spend on the login screen of proxy RDP before closing client window (0 to desactivate). <br/>
    /// type: std::chrono::seconds <br/>
    /// value{120} <br/>
    struct globals::authentication_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "authentication_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{120};
    };
    /// Specifies the time to spend on the close box of proxy RDP before closing client window (0 to desactivate). <br/>
    /// type: std::chrono::seconds <br/>
    /// value{600} <br/>
    struct globals::close_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "close_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    /// type: TraceType <br/>
    /// sesman ⇒ proxy <br/>
    /// value = static_cast<type>(1) <br/>
    struct globals::trace_type {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "trace_type";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(13);
        using type = TraceType;
        using sesman_and_spec_type = TraceType;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: std::string <br/>
    /// value = "0.0.0.0" <br/>
    struct globals::listen_address {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "listen_address";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::ip;
        using mapped_type = sesman_and_spec_type;
        type value = "0.0.0.0";
    };
    /// Allow Transparent mode. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::enable_transparent_mode {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_transparent_mode";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Proxy certificate password. <br/>
    /// type: char[255] <br/>
    /// value = "inquisition" <br/>
    struct globals::certificate_password {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "certificate_password";
        using type = char[255];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "inquisition";
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct globals::is_rec {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "is_rec";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(14);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// sesman::name: rec_path <br/>
    /// value{} <br/>
    struct globals::movie_path {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "movie_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(15);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Support of Bitmap Update. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_bitmap_update {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_bitmap_update";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Show close screen. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_close_box {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_close_box";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_osd {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_osd";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::enable_osd_display_remote_target {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_osd_display_remote_target";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value = REDEMPTION_CONFIG_ENABLE_WAB_INTEGRATION <br/>
    struct globals::enable_wab_integration {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "enable_wab_integration";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_ENABLE_WAB_INTEGRATION;
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::allow_using_multiple_monitors {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "allow_using_multiple_monitors";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Needed to refresh screen of Windows Server 2012. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::bogus_refresh_rect {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "bogus_refresh_rect";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::large_pointer_support {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "large_pointer_support";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{true} <br/>
    struct globals::unicode_keyboard_event_support {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "unicode_keyboard_event_support";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(16);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::chrono::milliseconds <br/>
    /// sesman ⇒ proxy <br/>
    /// value{1000} <br/>
    struct globals::mod_recv_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "mod_recv_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(17);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 100, 10000>;
        using mapped_type = sesman_and_spec_type;
        type value{1000};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::spark_view_specific_glyph_width {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "spark_view_specific_glyph_width";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct globals::experimental_enable_serializer_data_block_size_limit {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "experimental_enable_serializer_data_block_size_limit";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::experimental_support_resize_session_during_recording {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "experimental_support_resize_session_during_recording";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct globals::support_connection_redirection_during_recording {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "support_connection_redirection_during_recording";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Prevent Remote Desktop session timeouts due to idle tcp sessions by sending periodically keep alive packet to client. <br/>
    /// !!!May cause FreeRDP-based client to CRASH!!! <br/>
    /// Set to 0 to disable this feature. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// value{0} <br/>
    struct globals::rdp_keepalive_connection_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "globals";
        static constexpr char const * name = "rdp_keepalive_connection_interval";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };

    /// type: bool <br/>
    /// value{true} <br/>
    struct session_log::enable_session_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "enable_session_log";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct session_log::enable_arcsight_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "enable_arcsight_log";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Keyboard Input Masking Level: <br/>
    /// type: KeyboardInputMaskingLevel <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: session_log:keyboard_input_masking_level <br/>
    /// value = static_cast<type>(2) <br/>
    struct session_log::keyboard_input_masking_level {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "keyboard_input_masking_level";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(18);
        using type = KeyboardInputMaskingLevel;
        using sesman_and_spec_type = KeyboardInputMaskingLevel;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(2);
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct session_log::hide_non_printable_kbd_input {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "session_log";
        static constexpr char const * name = "hide_non_printable_kbd_input";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// type: unsigned int <br/>
    /// sesman ⇐ proxy <br/>
    /// value{0} <br/>
    struct client::keyboard_layout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "client";
        static constexpr char const * name = "keyboard_layout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(19);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// cs-CZ, da-DK, de-DE, el-GR, en-US, es-ES, fi-FI.finnish, fr-FR, is-IS, it-IT, nl-NL, nb-NO, pl-PL.programmers, pt-BR.abnt, ro-RO, ru-RU, hr-HR, sk-SK, sv-SE, tr-TR.q, uk-UA, sl-SI, et-EE, lv-LV, lt-LT.ibm, mk-MK, fo-FO, mt-MT.47, se-NO, kk-KZ, ky-KG, tt-RU, mn-MN, cy-GB, lb-LU, mi-NZ, de-CH, en-GB, es-MX, fr-BE.fr, nl-BE, pt-PT, sr-La, se-SE, uz-Cy, iu-La, fr-CA, sr-Cy, en-CA.fr, fr-CH, bs-Cy, bg-BG.latin, cs-CZ.qwerty, en-IE.irish, de-DE.ibm, el-GR.220, es-ES.variation, hu-HU, en-US.dvorak, it-IT.142, pl-PL, pt-BR.abnt2, ru-RU.typewriter, sk-SK.qwerty, tr-TR.f, lv-LV.qwerty, lt-LT, mt-MT.48, se-NO.ext_norway, fr-BE, se-SE, en-CA.multilingual, en-IE, cs-CZ.programmers, el-GR.319, en-US.international, se-SE.ext_finland_sweden, bg-BG, el-GR.220_latin, en-US.dvorak_left, el-GR.319_latin, en-US.dvorak_right, el-GR.latin, el-GR.polytonic <br/>
    /// type: std::string <br/>
    /// value = "en-US, fr-FR, de-DE, ru-RU" <br/>
    struct client::keyboard_layout_proposals {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "keyboard_layout_proposals";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value = "en-US, fr-FR, de-DE, ru-RU";
    };
    /// If true, ignore password provided by RDP client, user need do login manually. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::ignore_logon_password {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "ignore_logon_password";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Enable font smoothing (0x80). <br/>
    /// type: uint32_t <br/>
    /// value{128} <br/>
    struct client::performance_flags_default {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "performance_flags_default";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{128};
    };
    /// Disable theme (0x8). <br/>
    /// Disable mouse cursor shadows (0x20). <br/>
    /// type: uint32_t <br/>
    /// value{40} <br/>
    struct client::performance_flags_force_present {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "performance_flags_force_present";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };
    /// type: uint32_t <br/>
    /// value{0} <br/>
    struct client::performance_flags_force_not_present {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "performance_flags_force_not_present";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// If enabled, avoid automatically font smoothing in recorded session. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::auto_adjust_performance_flags {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "auto_adjust_performance_flags";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Fallback to RDP Legacy Encryption if client does not support TLS. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::tls_fallback_legacy {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "tls_fallback_legacy";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::tls_support {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "tls_support";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Minimal incoming TLS level 0=TLSv1, 1=TLSv1.1, 2=TLSv1.2, 3=TLSv1.3 <br/>
    /// type: unsigned int <br/>
    /// value{2} <br/>
    struct client::tls_min_level {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "tls_min_level";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2};
    };
    /// Maximal incoming TLS level 0=no restriction, 1=TLSv1.1, 2=TLSv1.2, 3=TLSv1.3 <br/>
    /// type: unsigned int <br/>
    /// value{0} <br/>
    struct client::tls_max_level {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "tls_max_level";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Show common cipher list supported by client and server <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::show_common_cipher_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "show_common_cipher_list";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Needed for primary NTLM or Kerberos connections over NLA. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::enable_nla {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_nla";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Needed to connect with jrdp, based on bogus X224 layer code. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::bogus_neg_request {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_neg_request";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Needed to connect with Remmina 0.8.3 and freerdp 0.9.4, based on bogus MCS layer code. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::bogus_user_id {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_user_id";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, ignore CTRL+ALT+DEL and CTRL+SHIFT+ESCAPE (or the equivalents) keyboard sequences. <br/>
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct client::disable_tsk_switch_shortcuts {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "disable_tsk_switch_shortcuts";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(20);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: RdpCompression <br/>
    /// value = static_cast<type>(4) <br/>
    struct client::rdp_compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "rdp_compression";
        using type = RdpCompression;
        using sesman_and_spec_type = RdpCompression;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(4);
    };
    /// type: ColorDepth <br/>
    /// value = static_cast<type>(24) <br/>
    struct client::max_color_depth {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "max_color_depth";
        using type = ColorDepth;
        using sesman_and_spec_type = ColorDepth;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(24);
    };
    /// Persistent Disk Bitmap Cache on the front side. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::persistent_disk_bitmap_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "persistent_disk_bitmap_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Support of Cache Waiting List (this value is ignored if Persistent Disk Bitmap Cache is disabled). <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::cache_waiting_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "cache_waiting_list";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// If enabled, the contents of Persistent Bitmap Caches are stored on disk. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::persist_bitmap_cache_on_disk {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "persist_bitmap_cache_on_disk";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Support of Bitmap Compression. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::bitmap_compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bitmap_compression";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Enables support of Client Fast-Path Input Event PDUs. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::fast_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "fast_path";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::enable_suppress_output {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_suppress_output";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// [Not configured]: Compatible with more RDP clients (less secure) <br/>
    /// HIGH:!ADH:!3DES: Compatible only with MS Windows 7 client or more recent (moderately secure)HIGH:!ADH:!3DES:!SHA: Compatible only with MS Server Windows 2008 R2 client or more recent (more secure) <br/>
    /// type: std::string <br/>
    /// value = "HIGH:!ADH:!3DES:!SHA" <br/>
    struct client::ssl_cipher_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "ssl_cipher_list";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "HIGH:!ADH:!3DES:!SHA";
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::show_target_user_in_f12_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "show_target_user_in_f12_message";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::enable_new_pointer_update {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_new_pointer_update";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::bogus_ios_glyph_support_level {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_ios_glyph_support_level";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::transform_glyph_to_bitmap {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "transform_glyph_to_bitmap";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: BogusNumberOfFastpathInputEvent <br/>
    /// value = static_cast<type>(1) <br/>
    struct client::bogus_number_of_fastpath_input_event {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_number_of_fastpath_input_event";
        using type = BogusNumberOfFastpathInputEvent;
        using sesman_and_spec_type = BogusNumberOfFastpathInputEvent;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: std::chrono::milliseconds <br/>
    /// value{1000} <br/>
    struct client::recv_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "recv_timeout";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 100, 10000>;
        using mapped_type = sesman_and_spec_type;
        type value{1000};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::enable_osd_4_eyes {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_osd_4_eyes";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Enable front remoteFx <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::enable_remotefx {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "enable_remotefx";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct client::bogus_pointer_xormask_padding {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "bogus_pointer_xormask_padding";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Disables supported drawing orders: <br/>
    ///    0: DstBlt <br/>
    ///    1: PatBlt <br/>
    ///    2: ScrBlt <br/>
    ///    3: MemBlt <br/>
    ///    4: Mem3Blt <br/>
    ///    8: LineTo <br/>
    ///   15: MultiDstBlt <br/>
    ///   16: MultiPatBlt <br/>
    ///   17: MultiScrBlt <br/>
    ///   18: MultiOpaqueRect <br/>
    ///   22: Polyline <br/>
    ///   25: EllipseSC <br/>
    ///   27: GlyphIndex <br/>
    /// type: std::string <br/>
    /// value = "25" <br/>
    struct client::disabled_orders {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "disabled_orders";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<unsigned int>;
        using mapped_type = sesman_and_spec_type;
        type value = "25";
    };
    /// Force usage of bitmap cache V2 for compatibility with WALLIX Access Manager. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct client::force_bitmap_cache_v2_with_am {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "client";
        static constexpr char const * name = "force_bitmap_cache_v2_with_am";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };

    /// type: RdpCompression <br/>
    /// value = static_cast<type>(4) <br/>
    struct mod_rdp::rdp_compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "rdp_compression";
        using type = RdpCompression;
        using sesman_and_spec_type = RdpCompression;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(4);
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::disconnect_on_logon_user_change {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "disconnect_on_logon_user_change";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::chrono::seconds <br/>
    /// value{0} <br/>
    struct mod_rdp::open_session_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "open_session_timeout";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Disables supported drawing orders: <br/>
    ///    0: DstBlt <br/>
    ///    1: PatBlt <br/>
    ///    2: ScrBlt <br/>
    ///    3: MemBlt <br/>
    ///    4: Mem3Blt <br/>
    ///    8: LineTo <br/>
    ///   15: MultiDstBlt <br/>
    ///   16: MultiPatBlt <br/>
    ///   17: MultiScrBlt <br/>
    ///   18: MultiOpaqueRect <br/>
    ///   22: Polyline <br/>
    ///   25: EllipseSC <br/>
    ///   27: GlyphIndex <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:disabled_orders <br/>
    /// value = "" <br/>
    struct mod_rdp::disabled_orders {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "disabled_orders";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(21);
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<unsigned int>;
        using mapped_type = sesman_and_spec_type;
        type value = "";
    };
    /// NLA authentication in secondary target. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:enable_nla <br/>
    /// value{true} <br/>
    struct mod_rdp::enable_nla {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_nla";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(22);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, NLA authentication will try Kerberos before NTLM. <br/>
    /// (if enable_nla is disabled, this value is ignored). <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:enable_kerberos <br/>
    /// value{false} <br/>
    struct mod_rdp::enable_kerberos {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_kerberos";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(23);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Minimal incoming TLS level 0=TLSv1, 1=TLSv1.1, 2=TLSv1.2, 3=TLSv1.3 <br/>
    /// type: unsigned int <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:tls_min_level <br/>
    /// value{0} <br/>
    struct mod_rdp::tls_min_level {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "tls_min_level";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(24);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Maximal incoming TLS level 0=no restriction, 1=TLSv1.1, 2=TLSv1.2, 3=TLSv1.3 <br/>
    /// type: unsigned int <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:tls_max_level <br/>
    /// value{0} <br/>
    struct mod_rdp::tls_max_level {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "tls_max_level";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(25);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// TLSv1.2 additional ciphers supported by client, default is empty to apply system-wide configuration (SSL security level 2), ALL for support of all ciphers to ensure highest compatibility with target servers. <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:cipher_string <br/>
    /// value = "ALL" <br/>
    struct mod_rdp::cipher_string {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "cipher_string";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(26);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "ALL";
    };
    /// Show common cipher list supported by client and server <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:show_common_cipher_list <br/>
    /// value{false} <br/>
    struct mod_rdp::show_common_cipher_list {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "show_common_cipher_list";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(27);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Persistent Disk Bitmap Cache on the mod side. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::persistent_disk_bitmap_cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "persistent_disk_bitmap_cache";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Support of Cache Waiting List (this value is ignored if Persistent Disk Bitmap Cache is disabled). <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::cache_waiting_list {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "cache_waiting_list";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// If enabled, the contents of Persistent Bitmap Caches are stored on disk. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::persist_bitmap_cache_on_disk {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "persist_bitmap_cache_on_disk";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Enables channels names (example: channel1,channel2,etc). Character * only, activate all with low priority. <br/>
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value = "*" <br/>
    struct mod_rdp::allow_channels {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "allow_channels";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(28);
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value = "*";
    };
    /// Disable channels names (example: channel1,channel2,etc). Character * only, deactivate all with low priority. <br/>
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::deny_channels {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "deny_channels";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(29);
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Enables support of Client/Server Fast-Path Input/Update PDUs. <br/>
    /// Fast-Path is required for Windows Server 2012 (or more recent)! <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::fast_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "fast_path";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Enables Server Redirection Support. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: mod_rdp::server_redirection] <br/>
    /// sesman::name: mod_rdp:server_redirection_support <br/>
    /// value{false} <br/>
    struct mod_rdp::server_redirection_support {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_redirection_support";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(30);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: RedirectionInfo <br/>
    /// value{} <br/>
    struct mod_rdp::redir_info {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "redir_info";
        using type = RedirectionInfo;
        using mapped_type = type;
        type value{};
    };
    /// Load balancing information <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:load_balance_info <br/>
    /// value{} <br/>
    struct mod_rdp::load_balance_info {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "load_balance_info";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(31);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Needed to connect with VirtualBox, based on bogus TS_UD_SC_NET data block. <br/>
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// sesman::name: rdp_bogus_sc_net_size <br/>
    /// value{true} <br/>
    struct mod_rdp::bogus_sc_net_size {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "bogus_sc_net_size";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(32);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::proxy_managed_drives {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "proxy_managed_drives";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(33);
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<std::string>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct mod_rdp::ignore_auth_channel {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "ignore_auth_channel";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(34);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Authentication channel used by Auto IT scripts. May be '*' to use default name. Keep empty to disable virtual channel. <br/>
    /// type: char[8] <br/>
    /// value = "*" <br/>
    struct mod_rdp::auth_channel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "auth_channel";
        using type = char[8];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "*";
    };
    /// Authentication channel used by other scripts. No default name. Keep empty to disable virtual channel. <br/>
    /// type: char[8] <br/>
    /// value = "" <br/>
    struct mod_rdp::checkout_channel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "checkout_channel";
        using type = char[8];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "";
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::alternate_shell {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "alternate_shell";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(35);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::shell_arguments {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "shell_arguments";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(36);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::shell_working_directory {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "shell_working_directory";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(37);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// As far as possible, use client-provided initial program (Alternate Shell) <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:use_client_provided_alternate_shell <br/>
    /// value{false} <br/>
    struct mod_rdp::use_client_provided_alternate_shell {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_client_provided_alternate_shell";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(38);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// As far as possible, use client-provided remote program (RemoteApp) <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:use_client_provided_remoteapp <br/>
    /// value{false} <br/>
    struct mod_rdp::use_client_provided_remoteapp {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_client_provided_remoteapp";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(39);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// As far as possible, use native RemoteApp capability <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:use_native_remoteapp_capability <br/>
    /// value{true} <br/>
    struct mod_rdp::use_native_remoteapp_capability {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_native_remoteapp_capability";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(40);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::enable_session_probe] <br/>
    /// sesman::name: mod_rdp:enable_session_probe <br/>
    /// value{false} <br/>
    struct mod_rdp::enable_session_probe {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_session_probe";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(41);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Minimum supported server : Windows Server 2008. <br/>
    /// Clipboard redirection should be remain enabled on Terminal Server. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::use_smart_launcher] <br/>
    /// sesman::name: mod_rdp:session_probe_use_smart_launcher <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_use_clipboard_based_launcher {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_use_clipboard_based_launcher";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(42);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::enable_launch_mask] <br/>
    /// sesman::name: mod_rdp:session_probe_enable_launch_mask <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_enable_launch_mask {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_launch_mask";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(43);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: SessionProbeOnLaunchFailure <br/>
    /// connpolicy -> proxy    [name: session_probe::on_launch_failure] <br/>
    /// sesman::name: mod_rdp:session_probe_on_launch_failure <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::session_probe_on_launch_failure {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_on_launch_failure";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(44);
        using type = SessionProbeOnLaunchFailure;
        using sesman_and_spec_type = SessionProbeOnLaunchFailure;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// This parameter is used if session_probe_on_launch_failure is 1 (disconnect user). <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::launch_timeout] <br/>
    /// sesman::name: mod_rdp:session_probe_launch_timeout <br/>
    /// value{40000} <br/>
    struct mod_rdp::session_probe_launch_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_launch_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(45);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>;
        using mapped_type = sesman_and_spec_type;
        type value{40000};
    };
    /// This parameter is used if session_probe_on_launch_failure is 0 (ignore failure and continue) or 2 (reconnect without Session Probe). <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::launch_fallback_timeout] <br/>
    /// sesman::name: mod_rdp:session_probe_launch_fallback_timeout <br/>
    /// value{10000} <br/>
    struct mod_rdp::session_probe_launch_fallback_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_launch_fallback_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(46);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>;
        using mapped_type = sesman_and_spec_type;
        type value{10000};
    };
    /// Minimum supported server : Windows Server 2008. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::start_launch_timeout_timer_only_after_logon] <br/>
    /// sesman::name: mod_rdp:session_probe_start_launch_timeout_timer_only_after_logon <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_start_launch_timeout_timer_only_after_logon";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(47);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::keepalive_timeout] <br/>
    /// sesman::name: mod_rdp:session_probe_keepalive_timeout <br/>
    /// value{5000} <br/>
    struct mod_rdp::session_probe_keepalive_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_keepalive_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(48);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 60000>;
        using mapped_type = sesman_and_spec_type;
        type value{5000};
    };
    /// type: SessionProbeOnKeepaliveTimeout <br/>
    /// connpolicy -> proxy    [name: session_probe::on_keepalive_timeout] <br/>
    /// sesman::name: mod_rdp:session_probe_on_keepalive_timeout <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::session_probe_on_keepalive_timeout {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_on_keepalive_timeout";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(49);
        using type = SessionProbeOnKeepaliveTimeout;
        using sesman_and_spec_type = SessionProbeOnKeepaliveTimeout;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// End automatically a disconnected session. <br/>
    /// Session Probe must be enabled to use this feature. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::end_disconnected_session] <br/>
    /// sesman::name: mod_rdp:session_probe_end_disconnected_session <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_end_disconnected_session {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_end_disconnected_session";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(50);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_customize_executable_name {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_customize_executable_name";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::enable_log] <br/>
    /// sesman::name: mod_rdp:session_probe_enable_log <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_enable_log {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_log";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(51);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::enable_log_rotation] <br/>
    /// sesman::name: mod_rdp:session_probe_enable_log_rotation <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_enable_log_rotation {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_log_rotation";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(52);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// This policy setting allows you to configure a time limit for disconnected application sessions. <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::disconnected_application_limit] <br/>
    /// sesman::name: mod_rdp:session_probe_disconnected_application_limit <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_disconnected_application_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_disconnected_application_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(53);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// This policy setting allows you to configure a time limit for disconnected Terminal Services sessions. <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::disconnected_session_limit] <br/>
    /// sesman::name: mod_rdp:session_probe_disconnected_session_limit <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_disconnected_session_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_disconnected_session_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(54);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// This parameter allows you to specify the maximum amount of time that an active Terminal Services session can be idle (without user input) before it is automatically locked by Session Probe. <br/>
    /// 0 to disable timeout. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::idle_session_limit] <br/>
    /// sesman::name: mod_rdp:session_probe_idle_session_limit <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_idle_session_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_idle_session_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(55);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 172800000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: char[512] <br/>
    /// value = "||CMD" <br/>
    struct mod_rdp::session_probe_exe_or_file {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_exe_or_file";
        using type = char[512];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = "||CMD";
    };
    /// type: char[512] <br/>
    /// value = REDEMPTION_CONFIG_SESSION_PROBE_ARGUMENTS <br/>
    struct mod_rdp::session_probe_arguments {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_arguments";
        using type = char[512];
        using sesman_and_spec_type = ::configs::spec_types::fixed_string;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_SESSION_PROBE_ARGUMENTS;
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::smart_launcher_clipboard_initialization_delay] <br/>
    /// sesman::name: mod_rdp:session_probe_clipboard_based_launcher_clipboard_initialization_delay <br/>
    /// value{2000} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_clipboard_initialization_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_clipboard_initialization_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(56);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{2000};
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::smart_launcher_start_delay] <br/>
    /// sesman::name: mod_rdp:session_probe_clipboard_based_launcher_start_delay <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_start_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_start_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(57);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::smart_launcher_long_delay] <br/>
    /// sesman::name: mod_rdp:session_probe_clipboard_based_launcher_long_delay <br/>
    /// value{500} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_long_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_long_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(58);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{500};
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::smart_launcher_short_delay] <br/>
    /// sesman::name: mod_rdp:session_probe_clipboard_based_launcher_short_delay <br/>
    /// value{50} <br/>
    struct mod_rdp::session_probe_clipboard_based_launcher_short_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_clipboard_based_launcher_short_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(59);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{50};
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::launcher_abort_delay] <br/>
    /// sesman::name: mod_rdp:session_probe_launcher_abort_delay <br/>
    /// value{2000} <br/>
    struct mod_rdp::session_probe_launcher_abort_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_launcher_abort_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(60);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 300000>;
        using mapped_type = sesman_and_spec_type;
        type value{2000};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_allow_multiple_handshake {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_allow_multiple_handshake";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::enable_crash_dump] <br/>
    /// sesman::name: mod_rdp:session_probe_enable_crash_dump <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_enable_crash_dump {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_enable_crash_dump";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(61);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: uint32_t <br/>
    /// connpolicy -> proxy    [name: session_probe::handle_usage_limit] <br/>
    /// sesman::name: mod_rdp:session_probe_handle_usage_limit <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_handle_usage_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_handle_usage_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(62);
        using type = uint32_t;
        using sesman_and_spec_type = ::configs::spec_types::range<uint32_t, 0, 1000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: uint32_t <br/>
    /// connpolicy -> proxy    [name: session_probe::memory_usage_limit] <br/>
    /// sesman::name: mod_rdp:session_probe_memory_usage_limit <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_memory_usage_limit {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_memory_usage_limit";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(63);
        using type = uint32_t;
        using sesman_and_spec_type = ::configs::spec_types::range<uint32_t, 0, 200000000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: session_probe::end_of_session_check_delay_time] <br/>
    /// sesman::name: mod_rdp:session_probe_end_of_session_check_delay_time <br/>
    /// value{0} <br/>
    struct mod_rdp::session_probe_end_of_session_check_delay_time {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_end_of_session_check_delay_time";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(64);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 0, 60000>;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::ignore_ui_less_processes_during_end_of_session_check] <br/>
    /// sesman::name: mod_rdp:session_probe_ignore_ui_less_processes_during_end_of_session_check <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_ignore_ui_less_processes_during_end_of_session_check {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_ignore_ui_less_processes_during_end_of_session_check";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(65);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::childless_window_as_unidentified_input_field] <br/>
    /// sesman::name: mod_rdp:session_probe_childless_window_as_unidentified_input_field <br/>
    /// value{true} <br/>
    struct mod_rdp::session_probe_childless_window_as_unidentified_input_field {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_childless_window_as_unidentified_input_field";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(66);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: SessionProbeDisabledFeature <br/>
    /// connpolicy -> proxy    [name: session_probe::disabled_features] <br/>
    /// sesman::name: mod_rdp:session_probe_disabled_features <br/>
    /// value = static_cast<type>(352) <br/>
    struct mod_rdp::session_probe_disabled_features {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_disabled_features";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(67);
        using type = SessionProbeDisabledFeature;
        using sesman_and_spec_type = SessionProbeDisabledFeature;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(352);
    };
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::enable_bestsafe_integration] <br/>
    /// sesman::name: mod_rdp:enable_bestsafe_integration <br/>
    /// value{} <br/>
    struct mod_rdp::enable_bestsafe_integration {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_bestsafe_integration";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(68);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// If enabled, disconnected session can be recovered by a different primary user. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: session_probe::public_session] <br/>
    /// sesman::name: mod_rdp:session_probe_public_session <br/>
    /// value{false} <br/>
    struct mod_rdp::session_probe_public_session {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_public_session";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(69);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: SessionProbeOnAccountManipulation <br/>
    /// connpolicy -> proxy    [name: session_probe::on_account_manipulation] <br/>
    /// sesman::name: mod_rdp:session_probe_on_account_manipulation <br/>
    /// value = static_cast<type>(0) <br/>
    struct mod_rdp::session_probe_on_account_manipulation {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_probe_on_account_manipulation";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(70);
        using type = SessionProbeOnAccountManipulation;
        using sesman_and_spec_type = SessionProbeOnAccountManipulation;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// Keep known server certificates on WAB <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: server_cert::server_cert_store] <br/>
    /// sesman::name: mod_rdp:server_cert_store <br/>
    /// value{true} <br/>
    struct mod_rdp::server_cert_store {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_store";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(71);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: ServerCertCheck <br/>
    /// connpolicy -> proxy    [name: server_cert::server_cert_check] <br/>
    /// sesman::name: mod_rdp:server_cert_check <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_check {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_check";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(72);
        using type = ServerCertCheck;
        using sesman_and_spec_type = ServerCertCheck;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn if check allow connexion to server. <br/>
    /// type: ServerNotification <br/>
    /// connpolicy -> proxy    [name: server_cert::server_access_allowed_message] <br/>
    /// sesman::name: mod_rdp:server_access_allowed_message <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_access_allowed_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_access_allowed_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(73);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that new server certificate file was created. <br/>
    /// type: ServerNotification <br/>
    /// connpolicy -> proxy    [name: server_cert::server_cert_create_message] <br/>
    /// sesman::name: mod_rdp:server_cert_create_message <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_create_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_create_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(74);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that server certificate file was successfully checked. <br/>
    /// type: ServerNotification <br/>
    /// connpolicy -> proxy    [name: server_cert::server_cert_success_message] <br/>
    /// sesman::name: mod_rdp:server_cert_success_message <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_success_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_success_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(75);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that server certificate file checking failed. <br/>
    /// type: ServerNotification <br/>
    /// connpolicy -> proxy    [name: server_cert::server_cert_failure_message] <br/>
    /// sesman::name: mod_rdp:server_cert_failure_message <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_failure_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_failure_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(76);
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Warn that server certificate check raised some internal error. <br/>
    /// type: ServerNotification <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_rdp::server_cert_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_error_message";
        using type = ServerNotification;
        using sesman_and_spec_type = ServerNotification;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Do not transmit client machine name or RDP server. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::hide_client_name {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "hide_client_name";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::clean_up_32_bpp_cursor {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "clean_up_32_bpp_cursor";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::bogus_ios_rdpdr_virtual_channel {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "bogus_ios_rdpdr_virtual_channel";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{true} <br/>
    struct mod_rdp::enable_rdpdr_data_analysis {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_rdpdr_data_analysis";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(77);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Delay before automatically bypass Windows's Legal Notice screen in RemoteApp mode. <br/>
    /// Set to 0 to disable this feature. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// value{0} <br/>
    struct mod_rdp::remoteapp_bypass_legal_notice_delay {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "remoteapp_bypass_legal_notice_delay";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// Time limit to automatically bypass Windows's Legal Notice screen in RemoteApp mode. <br/>
    /// Set to 0 to disable this feature. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// value{20000} <br/>
    struct mod_rdp::remoteapp_bypass_legal_notice_timeout {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "remoteapp_bypass_legal_notice_timeout";
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = std::chrono::milliseconds;
        using mapped_type = sesman_and_spec_type;
        type value{20000};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::log_only_relevant_clipboard_activities {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "log_only_relevant_clipboard_activities";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::experimental_fix_input_event_sync {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "experimental_fix_input_event_sync";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::experimental_fix_too_long_cookie {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "experimental_fix_too_long_cookie";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Force to split target domain and username with '@' separator. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::split_domain {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "split_domain";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:wabam_uses_translated_remoteapp <br/>
    /// value{false} <br/>
    struct mod_rdp::wabam_uses_translated_remoteapp {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "wabam_uses_translated_remoteapp";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(78);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::enable_server_cert_external_validation {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_server_cert_external_validation";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(79);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::server_cert {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(80);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// empty string for wait, 'Ok' or error message <br/>
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_rdp::server_cert_response {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "server_cert_response";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(81);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Enables Session Shadowing Support. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::session_shadowing_support {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "session_shadowing_support";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Stores CALs issued by the terminal servers. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct mod_rdp::use_license_store {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "use_license_store";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Enables support of the remoteFX codec. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:enable_remotefx <br/>
    /// value{false} <br/>
    struct mod_rdp::enable_remotefx {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_remotefx";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(82);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_rdp::accept_monitor_layout_change_if_capture_is_not_started {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "accept_monitor_layout_change_if_capture_is_not_started";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Connect to the server in Restricted Admin mode. <br/>
    /// This mode must be supported by the server (available from Windows Server 2012 R2), otherwise, connection will fail. <br/>
    /// NLA must be enabled. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:enable_restricted_admin_mode <br/>
    /// value{false} <br/>
    struct mod_rdp::enable_restricted_admin_mode {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "enable_restricted_admin_mode";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(83);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// NLA will be disabled. <br/>
    /// Target must be set for interactive login, otherwise server connection may not be guaranteed. <br/>
    /// Smartcard device must be available on client desktop. <br/>
    /// Smartcard redirection (Proxy option RDP_SMARTCARD) must be enabled on service. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_rdp:force_smartcard_authentication <br/>
    /// value{false} <br/>
    struct mod_rdp::force_smartcard_authentication {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_rdp";
        static constexpr char const * name = "force_smartcard_authentication";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(84);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// Enable or disable the clipboard from client (client to server). <br/>
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_vnc::clipboard_up {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "clipboard_up";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(85);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Enable or disable the clipboard from server (server to client). <br/>
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct mod_vnc::clipboard_down {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "clipboard_down";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(86);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Sets the encoding types in which pixel data can be sent by the VNC server: <br/>
    ///   0: Raw <br/>
    ///   1: CopyRect <br/>
    ///   2: RRE <br/>
    ///   16: ZRLE <br/>
    ///   -239 (0xFFFFFF11): Cursor pseudo-encoding <br/>
    /// type: std::string <br/>
    /// value{} <br/>
    struct mod_vnc::encodings {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "encodings";
        using type = std::string;
        using sesman_and_spec_type = ::configs::spec_types::list<int>;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// VNC server clipboard data encoding type. <br/>
    /// type: ClipboardEncodingType <br/>
    /// sesman ⇒ proxy <br/>
    /// sesman::name: vnc_server_clipboard_encoding_type <br/>
    /// value = static_cast<type>(1) <br/>
    struct mod_vnc::server_clipboard_encoding_type {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "server_clipboard_encoding_type";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(87);
        using type = ClipboardEncodingType;
        using sesman_and_spec_type = ClipboardEncodingType;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: VncBogusClipboardInfiniteLoop <br/>
    /// sesman ⇒ proxy <br/>
    /// sesman::name: vnc_bogus_clipboard_infinite_loop <br/>
    /// value = static_cast<type>(0) <br/>
    struct mod_vnc::bogus_clipboard_infinite_loop {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "bogus_clipboard_infinite_loop";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(88);
        using type = VncBogusClipboardInfiniteLoop;
        using sesman_and_spec_type = VncBogusClipboardInfiniteLoop;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_vnc:server_is_macos <br/>
    /// value{false} <br/>
    struct mod_vnc::server_is_macos {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "server_is_macos";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(89);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_vnc:server_unix_alt <br/>
    /// value{false} <br/>
    struct mod_vnc::server_unix_alt {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "server_unix_alt";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(90);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: mod_vnc:support_cursor_pseudo_encoding <br/>
    /// value{true} <br/>
    struct mod_vnc::support_cursor_pseudo_encoding {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_vnc";
        static constexpr char const * name = "support_cursor_pseudo_encoding";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(91);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };

    /// type: bool <br/>
    /// value{false} <br/>
    struct metrics::enable_rdp_metrics {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "enable_rdp_metrics";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct metrics::enable_vnc_metrics {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "enable_vnc_metrics";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = app_path(AppPath::Metrics).to_string() <br/>
    struct metrics::log_dir_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "log_dir_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Metrics).to_string();
    };
    /// type: std::chrono::seconds <br/>
    /// value{5} <br/>
    struct metrics::log_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "log_interval";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// type: std::chrono::hours <br/>
    /// value{24} <br/>
    struct metrics::log_file_turnover_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "log_file_turnover_interval";
        using type = std::chrono::hours;
        using sesman_and_spec_type = std::chrono::hours;
        using mapped_type = sesman_and_spec_type;
        type value{24};
    };
    /// signature key to digest log metrics header info <br/>
    /// type: std::string <br/>
    /// value = "" <br/>
    struct metrics::sign_key {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "metrics";
        static constexpr char const * name = "sign_key";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "";
    };

    /// type: std::string <br/>
    /// value = REDEMPTION_CONFIG_VALIDATOR_PATH <br/>
    struct file_verification::socket_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_verification";
        static constexpr char const * name = "socket_path";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = REDEMPTION_CONFIG_VALIDATOR_PATH;
    };
    /// Enable use of ICAP service for file verification on upload. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: file_verification:enable_up <br/>
    /// value{} <br/>
    struct file_verification::enable_up {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_verification";
        static constexpr char const * name = "enable_up";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(92);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Enable use of ICAP service for file verification on download. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: file_verification:enable_down <br/>
    /// value{} <br/>
    struct file_verification::enable_down {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_verification";
        static constexpr char const * name = "enable_down";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(93);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Verify text data via clipboard from client to server. <br/>
    /// File verification on upload must be enabled via option Enable up. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: file_verification:clipboard_text_up <br/>
    /// value{} <br/>
    struct file_verification::clipboard_text_up {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_verification";
        static constexpr char const * name = "clipboard_text_up";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(94);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Verify text data via clipboard from server to client <br/>
    /// File verification on download must be enabled via option Enable down. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: file_verification:clipboard_text_down <br/>
    /// value{} <br/>
    struct file_verification::clipboard_text_down {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_verification";
        static constexpr char const * name = "clipboard_text_down";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(95);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: file_verification:log_if_accepted <br/>
    /// value{true} <br/>
    struct file_verification::log_if_accepted {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_verification";
        static constexpr char const * name = "log_if_accepted";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(96);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };

    /// Enable storage of transferred files (via RDP Clipboard). <br/>
    /// type: RdpStoreFile <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: file_storage:store_file <br/>
    /// value = static_cast<type>(0) <br/>
    struct file_storage::store_file {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "file_storage";
        static constexpr char const * name = "store_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(97);
        using type = RdpStoreFile;
        using sesman_and_spec_type = RdpStoreFile;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };

    /// Ip or fqdn of ICAP server <br/>
    /// type: std::string <br/>
    /// value{} <br/>
    struct icap_server_down::host {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_down";
        static constexpr char const * name = "host";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Port of ICAP server <br/>
    /// type: unsigned int <br/>
    /// value{1344} <br/>
    struct icap_server_down::port {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_down";
        static constexpr char const * name = "port";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1344};
    };
    /// Service name on ICAP server <br/>
    /// type: std::string <br/>
    /// value = "avscan" <br/>
    struct icap_server_down::service_name {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_down";
        static constexpr char const * name = "service_name";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "avscan";
    };
    /// ICAP server uses tls <br/>
    /// type: bool <br/>
    /// value{} <br/>
    struct icap_server_down::tls {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_down";
        static constexpr char const * name = "tls";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Send X Context (Client-IP, Server-IP, Authenticated-User) to ICAP server <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct icap_server_down::enable_x_context {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_down";
        static constexpr char const * name = "enable_x_context";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Filename sent to ICAP as percent encoding <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct icap_server_down::filename_percent_encoding {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_down";
        static constexpr char const * name = "filename_percent_encoding";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// Ip or fqdn of ICAP server <br/>
    /// type: std::string <br/>
    /// value{} <br/>
    struct icap_server_up::host {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_up";
        static constexpr char const * name = "host";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Port of ICAP server <br/>
    /// type: unsigned int <br/>
    /// value{1344} <br/>
    struct icap_server_up::port {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_up";
        static constexpr char const * name = "port";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1344};
    };
    /// Service name on ICAP server <br/>
    /// type: std::string <br/>
    /// value = "avscan" <br/>
    struct icap_server_up::service_name {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_up";
        static constexpr char const * name = "service_name";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "avscan";
    };
    /// ICAP server uses tls <br/>
    /// type: bool <br/>
    /// value{} <br/>
    struct icap_server_up::tls {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_up";
        static constexpr char const * name = "tls";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Send X Context (Client-IP, Server-IP, Authenticated-User) to ICAP server <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct icap_server_up::enable_x_context {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_up";
        static constexpr char const * name = "enable_x_context";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Filename sent to ICAP as percent encoding <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct icap_server_up::filename_percent_encoding {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "icap_server_up";
        static constexpr char const * name = "filename_percent_encoding";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// 0 - Wait for Escape, 1 - End session <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct mod_replay::on_end_of_data {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_replay";
        static constexpr char const * name = "on_end_of_data";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// 0 - replay once, 1 - loop replay <br/>
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct mod_replay::replay_on_loop {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "mod_replay";
        static constexpr char const * name = "replay_on_loop";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(98);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// type: OcrVersion <br/>
    /// value = static_cast<type>(2) <br/>
    struct ocr::version {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "version";
        using type = OcrVersion;
        using sesman_and_spec_type = OcrVersion;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(2);
    };
    /// type: OcrLocale <br/>
    /// value = static_cast<type>(0) <br/>
    struct ocr::locale {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "locale";
        using type = OcrLocale;
        using sesman_and_spec_type = OcrLocale;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::chrono::duration<unsigned, std::ratio<1, 100>> <br/>
    /// value{100} <br/>
    struct ocr::interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "interval";
        using type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using mapped_type = sesman_and_spec_type;
        type value{100};
    };
    /// type: bool <br/>
    /// value{true} <br/>
    struct ocr::on_title_bar_only {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "on_title_bar_only";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// Expressed in percentage, <br/>
    ///   0   - all of characters need be recognized <br/>
    ///   100 - accept all results <br/>
    /// type: unsigned int <br/>
    /// value{40} <br/>
    struct ocr::max_unrecog_char_rate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "ocr";
        static constexpr char const * name = "max_unrecog_char_rate";
        using type = unsigned int;
        using sesman_and_spec_type = ::configs::spec_types::range<unsigned int, 0, 100>;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };

    /// type: unsigned int <br/>
    /// value{33} <br/>
    struct video::capture_groupid {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "capture_groupid";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{33};
    };
    /// type: CaptureFlags <br/>
    /// value = static_cast<type>(11) <br/>
    struct video::capture_flags {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "capture_flags";
        using type = CaptureFlags;
        using sesman_and_spec_type = CaptureFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(11);
    };
    /// Frame interval. <br/>
    /// type: std::chrono::duration<unsigned, std::ratio<1, 10>> <br/>
    /// value{10} <br/>
    struct video::png_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "png_interval";
        using type = std::chrono::duration<unsigned, std::ratio<1, 10>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned, std::ratio<1, 10>>;
        using mapped_type = sesman_and_spec_type;
        type value{10};
    };
    /// Frame interval. <br/>
    /// type: std::chrono::duration<unsigned, std::ratio<1, 100>> <br/>
    /// value{40} <br/>
    struct video::frame_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "frame_interval";
        using type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using sesman_and_spec_type = std::chrono::duration<unsigned, std::ratio<1, 100>>;
        using mapped_type = sesman_and_spec_type;
        type value{40};
    };
    /// Time between 2 wrm movies. <br/>
    /// type: std::chrono::seconds <br/>
    /// value{600} <br/>
    struct video::break_interval {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "break_interval";
        using type = std::chrono::seconds;
        using sesman_and_spec_type = std::chrono::seconds;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    /// Number of png captures to keep. <br/>
    /// type: unsigned int <br/>
    /// value{5} <br/>
    struct video::png_limit {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "png_limit";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// value = "/tmp/" <br/>
    struct video::replay_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "replay_path";
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = "/tmp/";
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// sesman ⇒ proxy <br/>
    /// value = app_path(AppPath::Hash).to_string() <br/>
    struct video::hash_path {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "hash_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(99);
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Hash).to_string();
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// sesman ⇒ proxy <br/>
    /// value = app_path(AppPath::RecordTmp).to_string() <br/>
    struct video::record_tmp_path {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "record_tmp_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(100);
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::RecordTmp).to_string();
    };
    /// type: ::configs::spec_types::directory_path <br/>
    /// sesman ⇒ proxy <br/>
    /// value = app_path(AppPath::Record).to_string() <br/>
    struct video::record_path {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "record_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(101);
        using type = ::configs::spec_types::directory_path;
        using sesman_and_spec_type = ::configs::spec_types::directory_path;
        using mapped_type = sesman_and_spec_type;
        type value = app_path(AppPath::Record).to_string();
    };
    /// Disable keyboard log: <br/>
    /// (Please see also "Keyboard input masking level" in "session_log" section of "Connection Policy".) <br/>
    /// type: KeyboardLogFlags <br/>
    /// connpolicy -> proxy <br/>
    /// sesman::name: video:disable_keyboard_log <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::disable_keyboard_log {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "disable_keyboard_log";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(102);
        using type = KeyboardLogFlags;
        using sesman_and_spec_type = KeyboardLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Disable clipboard log: <br/>
    /// type: ClipboardLogFlags <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::disable_clipboard_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "disable_clipboard_log";
        using type = ClipboardLogFlags;
        using sesman_and_spec_type = ClipboardLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Disable (redirected) file system log: <br/>
    /// type: FileSystemLogFlags <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::disable_file_system_log {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "disable_file_system_log";
        using type = FileSystemLogFlags;
        using sesman_and_spec_type = FileSystemLogFlags;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct video::rt_display {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "rt_display";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(103);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: ColorDepthSelectionStrategy <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::wrm_color_depth_selection_strategy {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "wrm_color_depth_selection_strategy";
        using type = ColorDepthSelectionStrategy;
        using sesman_and_spec_type = ColorDepthSelectionStrategy;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// type: WrmCompressionAlgorithm <br/>
    /// value = static_cast<type>(1) <br/>
    struct video::wrm_compression_algorithm {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "wrm_compression_algorithm";
        using type = WrmCompressionAlgorithm;
        using sesman_and_spec_type = WrmCompressionAlgorithm;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(1);
    };
    /// Needed to play a video with ffplay or VLC. <br/>
    /// Note: Useless with mpv and mplayer. <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct video::bogus_vlc_frame_rate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "bogus_vlc_frame_rate";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::string <br/>
    /// value = "mp4" <br/>
    struct video::codec_id {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "codec_id";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "mp4";
    };
    /// type: unsigned int <br/>
    /// value{5} <br/>
    struct video::framerate {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "framerate";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{5};
    };
    /// FFmpeg options for video codec. <br/>
    /// type: std::string <br/>
    /// value = "profile=baseline preset=ultrafast flags=+qscale b=80000" <br/>
    struct video::ffmpeg_options {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "ffmpeg_options";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "profile=baseline preset=ultrafast flags=+qscale b=80000";
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct video::notimestamp {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "notimestamp";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: SmartVideoCropping <br/>
    /// value = static_cast<type>(0) <br/>
    struct video::smart_video_cropping {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "smart_video_cropping";
        using type = SmartVideoCropping;
        using sesman_and_spec_type = SmartVideoCropping;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// Needed to play a video with corrupted Bitmap Update. <br/>
    /// Note: Useless with mpv and mplayer. <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct video::play_video_with_corrupted_bitmap {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "video";
        static constexpr char const * name = "play_video_with_corrupted_bitmap";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };

    /// basename without extension <br/>
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct capture::record_filebase {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "capture";
        static constexpr char const * name = "record_filebase";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(104);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// subdirectory of record_path (video section) <br/>
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct capture::record_subdirectory {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "capture";
        static constexpr char const * name = "record_subdirectory";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(105);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct capture::fdx_path {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "capture";
        static constexpr char const * name = "fdx_path";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(106);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    /// type: std::array<unsigned char, 32> <br/>
    /// sesman ⇒ proxy <br/>
    /// value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }} <br/>
    struct crypto::key0 {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "crypto";
        static constexpr char const * name = "key0";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(107);
        using type = std::array<unsigned char, 32>;
        using sesman_and_spec_type = ::configs::spec_types::fixed_binary;
        using mapped_type = sesman_and_spec_type;
        type value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }};
    };
    /// type: std::array<unsigned char, 32> <br/>
    /// sesman ⇒ proxy <br/>
    /// value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }} <br/>
    struct crypto::key1 {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "crypto";
        static constexpr char const * name = "key1";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(108);
        using type = std::array<unsigned char, 32>;
        using sesman_and_spec_type = ::configs::spec_types::fixed_binary;
        using mapped_type = sesman_and_spec_type;
        type value{{0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F, }};
    };

    /// Enable websocket protocol (ws or wss with use_tls=1) <br/>
    /// type: bool <br/>
    /// value{false} <br/>
    struct websocket::enable_websocket {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "websocket";
        static constexpr char const * name = "enable_websocket";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// Use TLS with websocket (wss) <br/>
    /// type: bool <br/>
    /// value{true} <br/>
    struct websocket::use_tls {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "websocket";
        static constexpr char const * name = "use_tls";
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// ${addr}:${port} or ${port} or ${unix_socket_path} <br/>
    /// type: std::string <br/>
    /// value = ":3390" <br/>
    struct websocket::listen_address {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "websocket";
        static constexpr char const * name = "listen_address";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = ":3390";
    };

    /// type: std::string <br/>
    /// value{} <br/>
    struct debug::fake_target_ip {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "fake_target_ip";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::primary_orders {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "primary_orders";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::secondary_orders {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "secondary_orders";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::bitmap_update {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "bitmap_update";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::capture {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "capture";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::auth {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "auth";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::session {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "session";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::front {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "front";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_rdp {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_rdp";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_vnc {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_vnc";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_internal {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_internal";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::mod_xup {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "mod_xup";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::password {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "password";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::compression {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "compression";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::cache {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "cache";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::performance {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "performance";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::pass_dialog_box {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "pass_dialog_box";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::ocr {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "ocr";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: uint32_t <br/>
    /// value{} <br/>
    struct debug::ffmpeg {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "ffmpeg";
        using type = uint32_t;
        using sesman_and_spec_type = uint32_t;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// value{2} <br/>
    struct debug::config {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "debug";
        static constexpr char const * name = "config";
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{2};
    };

    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{true} <br/>
    struct remote_program::allow_resize_hosted_desktop {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "remote_program";
        static constexpr char const * name = "allow_resize_hosted_desktop";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(109);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };

    /// type: Language <br/>
    /// sesman ⇒ proxy <br/>
    /// value = static_cast<type>(0) <br/>
    struct translation::language {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "translation";
        static constexpr char const * name = "language";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(110);
        using type = Language;
        using sesman_and_spec_type = Language;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct translation::password_en {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "translation";
        static constexpr char const * name = "password_en";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(111);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct translation::password_fr {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "translation";
        static constexpr char const * name = "password_fr";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(112);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    /// type: std::string <br/>
    /// value{} <br/>
    struct internal_mod::theme {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "internal_mod";
        static constexpr char const * name = "theme";
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

    /// Proxy session log id <br/>
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::psid {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "psid";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(113);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: ColorDepth <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: bpp <br/>
    /// value = static_cast<type>(24) <br/>
    struct context::opt_bpp {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_bpp";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(114);
        using type = ColorDepth;
        using sesman_and_spec_type = ColorDepth;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(24);
    };
    /// type: uint16_t <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: height <br/>
    /// value{600} <br/>
    struct context::opt_height {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_height";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(115);
        using type = uint16_t;
        using sesman_and_spec_type = uint16_t;
        using mapped_type = sesman_and_spec_type;
        type value{600};
    };
    /// type: uint16_t <br/>
    /// sesman ⇔ proxy <br/>
    /// sesman::name: width <br/>
    /// value{800} <br/>
    struct context::opt_width {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_width";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(116);
        using type = uint16_t;
        using sesman_and_spec_type = uint16_t;
        using mapped_type = sesman_and_spec_type;
        type value{800};
    };
    /// type: std::string <br/>
    /// value{} <br/>
    struct context::auth_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_error_message";
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct context::selector {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(117);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: unsigned int <br/>
    /// sesman ⇔ proxy <br/>
    /// value{1} <br/>
    struct context::selector_current_page {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_current_page";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(118);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::selector_device_filter {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_device_filter";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(119);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::selector_group_filter {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_group_filter";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(120);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::selector_proto_filter {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_proto_filter";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(121);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇔ proxy <br/>
    /// value{0} <br/>
    struct context::selector_lines_per_page {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_lines_per_page";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(122);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: unsigned int <br/>
    /// sesman ⇒ proxy <br/>
    /// value{1} <br/>
    struct context::selector_number_of_pages {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "selector_number_of_pages";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(123);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{1};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::target_password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(124);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::target_host {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_host";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(125);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::target_str {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_str";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(126);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::target_service {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_service";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(127);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇔ proxy <br/>
    /// value{3389} <br/>
    struct context::target_port {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_port";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(128);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{3389};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// sesman::name: proto_dest <br/>
    /// value = "RDP" <br/>
    struct context::target_protocol {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "target_protocol";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(129);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "RDP";
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(130);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::nla_password_hash {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "nla_password_hash";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(131);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::reporting {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "reporting";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(132);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_channel_answer {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_channel_answer";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(133);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::auth_channel_target {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_channel_target";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(134);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(135);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::accept_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "accept_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(136);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::display_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "display_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(137);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::rejected {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rejected";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(138);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇔ proxy <br/>
    /// value{false} <br/>
    struct context::authenticated {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "authenticated";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(139);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct context::keepalive {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "keepalive";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(140);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::session_id {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(141);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇒ proxy <br/>
    /// sesman::name: timeclose <br/>
    /// value{0} <br/>
    struct context::end_date_cnx {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "end_date_cnx";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(142);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: RdpModeConsole <br/>
    /// sesman ⇒ proxy <br/>
    /// value = static_cast<type>(0) <br/>
    struct context::mode_console {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "mode_console";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(143);
        using type = RdpModeConsole;
        using sesman_and_spec_type = RdpModeConsole;
        using mapped_type = sesman_and_spec_type;
        type value = static_cast<type>(0);
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::real_target_device {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "real_target_device";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(144);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::authentication_challenge {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "authentication_challenge";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(145);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::ticket {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "ticket";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(146);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::comment {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "comment";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(147);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::duration {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "duration";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(148);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇒ proxy <br/>
    /// value{0} <br/>
    struct context::duration_max {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "duration_max";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(149);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::waitinforeturn {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "waitinforeturn";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(150);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct context::showform {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "showform";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(151);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: unsigned int <br/>
    /// sesman ⇔ proxy <br/>
    /// value{0} <br/>
    struct context::formflag {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "formflag";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(152);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{0};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value = "login" <br/>
    struct context::module {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "module";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(153);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value = "login";
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct context::forcemodule {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "forcemodule";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(154);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::proxy_opt {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "proxy_opt";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(155);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::pattern_kill {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pattern_kill";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(156);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::pattern_notify {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pattern_notify";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(157);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::opt_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "opt_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(158);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::login_message {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "login_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(159);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated rules (Ex.: $deny:192.168.0.0/24:*,$allow:host.domain.net:3389,$allow:192.168.0.110:*) <br/>
    /// (Ex. for backwards compatibility only: 10.1.0.0/16:22) <br/>
    /// Session Probe must be enabled to use this feature. <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy    [name: session_probe::outbound_connection_monitoring_rules] <br/>
    /// sesman::name: context:session_probe_outbound_connection_monitoring_rules <br/>
    /// value{} <br/>
    struct context::session_probe_outbound_connection_monitoring_rules {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_outbound_connection_monitoring_rules";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(160);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated rules (Ex.: $deny:Taskmgr) <br/>
    /// @ = All child processes of Bastion Application (Ex.: $deny:@) <br/>
    /// Session Probe must be enabled to use this feature. <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy    [name: session_probe::process_monitoring_rules] <br/>
    /// sesman::name: context:session_probe_process_monitoring_rules <br/>
    /// value{} <br/>
    struct context::session_probe_process_monitoring_rules {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_process_monitoring_rules";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(161);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated extra system processes (Ex.: dllhos.exe,TSTheme.exe) <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy    [name: session_probe::extra_system_processes] <br/>
    /// sesman::name: context:session_probe_extra_system_processes <br/>
    /// value{} <br/>
    struct context::session_probe_extra_system_processes {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_extra_system_processes";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(162);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Comma-separated processes (Ex.: chrome.exe,ngf.exe) <br/>
    /// type: std::string <br/>
    /// connpolicy -> proxy    [name: session_probe::windows_of_these_applications_as_unidentified_input_field] <br/>
    /// sesman::name: context:session_probe_windows_of_these_applications_as_unidentified_input_field <br/>
    /// value{} <br/>
    struct context::session_probe_windows_of_these_applications_as_unidentified_input_field {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_windows_of_these_applications_as_unidentified_input_field";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(163);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::disconnect_reason {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "disconnect_reason";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(164);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇐ proxy <br/>
    /// value{false} <br/>
    struct context::disconnect_reason_ack {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "disconnect_reason_ack";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(165);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// value{} <br/>
    struct context::ip_target {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "ip_target";
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇐ proxy <br/>
    /// value{false} <br/>
    struct context::recording_started {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "recording_started";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(166);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// sesman ⇔ proxy <br/>
    /// value{false} <br/>
    struct context::rt_ready {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rt_ready";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(167);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct context::perform_automatic_reconnection {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "perform_automatic_reconnection";
        using type = bool;
        using mapped_type = type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(168);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::auth_notify {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_notify";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(169);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::auth_notify_rail_exec_flags {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_notify_rail_exec_flags";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(170);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::auth_notify_rail_exec_exe_or_file {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_notify_rail_exec_exe_or_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(171);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_exec_result {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_exec_result";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(172);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_flags {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_flags";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(173);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_original_exe_or_file {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_original_exe_or_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(174);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_exe_or_file {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_exe_or_file";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(175);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_working_dir {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_working_dir";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(176);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_arguments {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_arguments";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(177);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_account {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_account";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(178);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::auth_command_rail_exec_password {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "auth_command_rail_exec_password";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(179);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// Delay before showing disconnect message after the last RemoteApp window is closed. <br/>
    /// type: std::chrono::milliseconds <br/>
    /// connpolicy -> proxy    [name: rdp::remote_programs_disconnect_message_delay] <br/>
    /// sesman::name: context:rail_disconnect_message_delay <br/>
    /// value{3000} <br/>
    struct context::rail_disconnect_message_delay {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rail_disconnect_message_delay";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(180);
        using type = std::chrono::milliseconds;
        using sesman_and_spec_type = ::configs::spec_types::range<std::chrono::milliseconds, 3000, 120000>;
        using mapped_type = sesman_and_spec_type;
        type value{3000};
    };
    /// Use Session Probe to launch Remote Program as much as possible. <br/>
    /// type: bool <br/>
    /// connpolicy -> proxy    [name: rdp::use_session_probe_to_launch_remote_program] <br/>
    /// sesman::name: context:use_session_probe_to_launch_remote_program <br/>
    /// value{true} <br/>
    struct context::use_session_probe_to_launch_remote_program {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "use_session_probe_to_launch_remote_program";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(181);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{true};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::session_probe_launch_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "session_probe_launch_error_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(182);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// value{} <br/>
    struct context::close_box_extra_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "close_box_extra_message";
        using type = std::string;
        using mapped_type = type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇒ proxy <br/>
    /// value{false} <br/>
    struct context::is_wabam {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "is_wabam";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(183);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::pm_response {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pm_response";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(184);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::pm_request {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "pm_request";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(185);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::native_session_id {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "native_session_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(186);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// sesman ⇐ proxy <br/>
    /// value{false} <br/>
    struct context::rd_shadow_available {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_available";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(187);
        using type = bool;
        using sesman_and_spec_type = bool;
        using mapped_type = sesman_and_spec_type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇔ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_userdata {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_userdata";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(188);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇒ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_type {
        static constexpr bool is_sesman_to_proxy = true;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_type";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(189);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_invitation_error_code {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_invitation_error_code";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(190);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_invitation_error_message {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_invitation_error_message";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(191);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_invitation_id {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_invitation_id";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(192);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_invitation_addr {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_invitation_addr";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(193);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: unsigned int <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::rd_shadow_invitation_port {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rd_shadow_invitation_port";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(194);
        using type = unsigned int;
        using sesman_and_spec_type = unsigned int;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };
    /// type: bool <br/>
    /// value{false} <br/>
    struct context::rail_module_host_mod_is_active {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = false;
        static constexpr char const * section = "context";
        static constexpr char const * name = "rail_module_host_mod_is_active";
        using type = bool;
        using mapped_type = type;
        type value{false};
    };
    /// type: std::string <br/>
    /// sesman ⇐ proxy <br/>
    /// value{} <br/>
    struct context::smartcard_login {
        static constexpr bool is_sesman_to_proxy = false;
        static constexpr bool is_proxy_to_sesman = true;
        static constexpr char const * section = "context";
        static constexpr char const * name = "smartcard_login";
        // for old cppcheck
        // cppcheck-suppress obsoleteFunctionsindex
        static constexpr authid_t index = authid_t(195);
        using type = std::string;
        using sesman_and_spec_type = std::string;
        using mapped_type = sesman_and_spec_type;
        type value{};
    };

} // namespace cfg

namespace cfg_section {
struct globals
: cfg::globals::nla_auth_user
, cfg::globals::auth_user
, cfg::globals::host
, cfg::globals::target
, cfg::globals::target_device
, cfg::globals::device_id
, cfg::globals::primary_user_id
, cfg::globals::target_user
, cfg::globals::target_application
, cfg::globals::target_application_account
, cfg::globals::target_application_password
, cfg::globals::authfile
, cfg::globals::handshake_timeout
, cfg::globals::session_timeout
, cfg::globals::inactivity_timeout
, cfg::globals::keepalive_grace_delay
, cfg::globals::authentication_timeout
, cfg::globals::close_timeout
, cfg::globals::movie_path
, cfg::globals::rdp_keepalive_connection_interval
, cfg::globals::port
, cfg::globals::capture_chunk
, cfg::globals::glyph_cache
, cfg::globals::nomouse
, cfg::globals::encryptionLevel
, cfg::globals::trace_type
, cfg::globals::listen_address
, cfg::globals::enable_transparent_mode
, cfg::globals::certificate_password
, cfg::globals::is_rec
, cfg::globals::enable_bitmap_update
, cfg::globals::enable_close_box
, cfg::globals::enable_osd
, cfg::globals::enable_osd_display_remote_target
, cfg::globals::enable_wab_integration
, cfg::globals::allow_using_multiple_monitors
, cfg::globals::bogus_refresh_rect
, cfg::globals::large_pointer_support
, cfg::globals::unicode_keyboard_event_support
, cfg::globals::mod_recv_timeout
, cfg::globals::spark_view_specific_glyph_width
, cfg::globals::experimental_enable_serializer_data_block_size_limit
, cfg::globals::experimental_support_resize_session_during_recording
, cfg::globals::support_connection_redirection_during_recording
{ static constexpr bool is_section = true; };

struct session_log
: cfg::session_log::enable_session_log
, cfg::session_log::enable_arcsight_log
, cfg::session_log::keyboard_input_masking_level
, cfg::session_log::hide_non_printable_kbd_input
{ static constexpr bool is_section = true; };

struct client
: cfg::client::ssl_cipher_list
, cfg::client::keyboard_layout
, cfg::client::tls_min_level
, cfg::client::tls_max_level
, cfg::client::keyboard_layout_proposals
, cfg::client::ignore_logon_password
, cfg::client::performance_flags_default
, cfg::client::performance_flags_force_present
, cfg::client::performance_flags_force_not_present
, cfg::client::auto_adjust_performance_flags
, cfg::client::tls_fallback_legacy
, cfg::client::tls_support
, cfg::client::show_common_cipher_list
, cfg::client::enable_nla
, cfg::client::bogus_neg_request
, cfg::client::bogus_user_id
, cfg::client::disable_tsk_switch_shortcuts
, cfg::client::rdp_compression
, cfg::client::max_color_depth
, cfg::client::persistent_disk_bitmap_cache
, cfg::client::cache_waiting_list
, cfg::client::persist_bitmap_cache_on_disk
, cfg::client::bitmap_compression
, cfg::client::fast_path
, cfg::client::enable_suppress_output
, cfg::client::show_target_user_in_f12_message
, cfg::client::enable_new_pointer_update
, cfg::client::bogus_ios_glyph_support_level
, cfg::client::transform_glyph_to_bitmap
, cfg::client::bogus_number_of_fastpath_input_event
, cfg::client::recv_timeout
, cfg::client::enable_osd_4_eyes
, cfg::client::enable_remotefx
, cfg::client::bogus_pointer_xormask_padding
, cfg::client::disabled_orders
, cfg::client::force_bitmap_cache_v2_with_am
{ static constexpr bool is_section = true; };

struct mod_rdp
: cfg::mod_rdp::open_session_timeout
, cfg::mod_rdp::cipher_string
, cfg::mod_rdp::load_balance_info
, cfg::mod_rdp::alternate_shell
, cfg::mod_rdp::shell_arguments
, cfg::mod_rdp::shell_working_directory
, cfg::mod_rdp::session_probe_clipboard_based_launcher_clipboard_initialization_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_start_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_long_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_short_delay
, cfg::mod_rdp::remoteapp_bypass_legal_notice_delay
, cfg::mod_rdp::remoteapp_bypass_legal_notice_timeout
, cfg::mod_rdp::server_cert
, cfg::mod_rdp::server_cert_response
, cfg::mod_rdp::tls_min_level
, cfg::mod_rdp::tls_max_level
, cfg::mod_rdp::session_probe_disabled_features
, cfg::mod_rdp::rdp_compression
, cfg::mod_rdp::disconnect_on_logon_user_change
, cfg::mod_rdp::disabled_orders
, cfg::mod_rdp::enable_nla
, cfg::mod_rdp::enable_kerberos
, cfg::mod_rdp::show_common_cipher_list
, cfg::mod_rdp::persistent_disk_bitmap_cache
, cfg::mod_rdp::cache_waiting_list
, cfg::mod_rdp::persist_bitmap_cache_on_disk
, cfg::mod_rdp::allow_channels
, cfg::mod_rdp::deny_channels
, cfg::mod_rdp::fast_path
, cfg::mod_rdp::server_redirection_support
, cfg::mod_rdp::redir_info
, cfg::mod_rdp::bogus_sc_net_size
, cfg::mod_rdp::proxy_managed_drives
, cfg::mod_rdp::ignore_auth_channel
, cfg::mod_rdp::auth_channel
, cfg::mod_rdp::checkout_channel
, cfg::mod_rdp::use_client_provided_alternate_shell
, cfg::mod_rdp::use_client_provided_remoteapp
, cfg::mod_rdp::use_native_remoteapp_capability
, cfg::mod_rdp::enable_session_probe
, cfg::mod_rdp::session_probe_use_clipboard_based_launcher
, cfg::mod_rdp::session_probe_enable_launch_mask
, cfg::mod_rdp::session_probe_on_launch_failure
, cfg::mod_rdp::session_probe_launch_timeout
, cfg::mod_rdp::session_probe_launch_fallback_timeout
, cfg::mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon
, cfg::mod_rdp::session_probe_keepalive_timeout
, cfg::mod_rdp::session_probe_on_keepalive_timeout
, cfg::mod_rdp::session_probe_end_disconnected_session
, cfg::mod_rdp::session_probe_customize_executable_name
, cfg::mod_rdp::session_probe_enable_log
, cfg::mod_rdp::session_probe_enable_log_rotation
, cfg::mod_rdp::session_probe_disconnected_application_limit
, cfg::mod_rdp::session_probe_disconnected_session_limit
, cfg::mod_rdp::session_probe_idle_session_limit
, cfg::mod_rdp::session_probe_exe_or_file
, cfg::mod_rdp::session_probe_arguments
, cfg::mod_rdp::session_probe_launcher_abort_delay
, cfg::mod_rdp::session_probe_allow_multiple_handshake
, cfg::mod_rdp::session_probe_enable_crash_dump
, cfg::mod_rdp::session_probe_handle_usage_limit
, cfg::mod_rdp::session_probe_memory_usage_limit
, cfg::mod_rdp::session_probe_end_of_session_check_delay_time
, cfg::mod_rdp::session_probe_ignore_ui_less_processes_during_end_of_session_check
, cfg::mod_rdp::session_probe_childless_window_as_unidentified_input_field
, cfg::mod_rdp::enable_bestsafe_integration
, cfg::mod_rdp::session_probe_public_session
, cfg::mod_rdp::session_probe_on_account_manipulation
, cfg::mod_rdp::server_cert_store
, cfg::mod_rdp::server_cert_check
, cfg::mod_rdp::server_access_allowed_message
, cfg::mod_rdp::server_cert_create_message
, cfg::mod_rdp::server_cert_success_message
, cfg::mod_rdp::server_cert_failure_message
, cfg::mod_rdp::server_cert_error_message
, cfg::mod_rdp::hide_client_name
, cfg::mod_rdp::clean_up_32_bpp_cursor
, cfg::mod_rdp::bogus_ios_rdpdr_virtual_channel
, cfg::mod_rdp::enable_rdpdr_data_analysis
, cfg::mod_rdp::log_only_relevant_clipboard_activities
, cfg::mod_rdp::experimental_fix_input_event_sync
, cfg::mod_rdp::experimental_fix_too_long_cookie
, cfg::mod_rdp::split_domain
, cfg::mod_rdp::wabam_uses_translated_remoteapp
, cfg::mod_rdp::enable_server_cert_external_validation
, cfg::mod_rdp::session_shadowing_support
, cfg::mod_rdp::use_license_store
, cfg::mod_rdp::enable_remotefx
, cfg::mod_rdp::accept_monitor_layout_change_if_capture_is_not_started
, cfg::mod_rdp::enable_restricted_admin_mode
, cfg::mod_rdp::force_smartcard_authentication
{ static constexpr bool is_section = true; };

struct mod_vnc
: cfg::mod_vnc::clipboard_up
, cfg::mod_vnc::clipboard_down
, cfg::mod_vnc::encodings
, cfg::mod_vnc::server_clipboard_encoding_type
, cfg::mod_vnc::bogus_clipboard_infinite_loop
, cfg::mod_vnc::server_is_macos
, cfg::mod_vnc::server_unix_alt
, cfg::mod_vnc::support_cursor_pseudo_encoding
{ static constexpr bool is_section = true; };

struct metrics
: cfg::metrics::log_interval
, cfg::metrics::log_file_turnover_interval
, cfg::metrics::sign_key
, cfg::metrics::enable_rdp_metrics
, cfg::metrics::enable_vnc_metrics
, cfg::metrics::log_dir_path
{ static constexpr bool is_section = true; };

struct file_verification
: cfg::file_verification::socket_path
, cfg::file_verification::enable_up
, cfg::file_verification::enable_down
, cfg::file_verification::clipboard_text_up
, cfg::file_verification::clipboard_text_down
, cfg::file_verification::log_if_accepted
{ static constexpr bool is_section = true; };

struct file_storage
: cfg::file_storage::store_file
{ static constexpr bool is_section = true; };

struct icap_server_down
: cfg::icap_server_down::host
, cfg::icap_server_down::service_name
, cfg::icap_server_down::port
, cfg::icap_server_down::tls
, cfg::icap_server_down::enable_x_context
, cfg::icap_server_down::filename_percent_encoding
{ static constexpr bool is_section = true; };

struct icap_server_up
: cfg::icap_server_up::host
, cfg::icap_server_up::service_name
, cfg::icap_server_up::port
, cfg::icap_server_up::tls
, cfg::icap_server_up::enable_x_context
, cfg::icap_server_up::filename_percent_encoding
{ static constexpr bool is_section = true; };

struct mod_replay
: cfg::mod_replay::on_end_of_data
, cfg::mod_replay::replay_on_loop
{ static constexpr bool is_section = true; };

struct ocr
: cfg::ocr::interval
, cfg::ocr::version
, cfg::ocr::locale
, cfg::ocr::on_title_bar_only
, cfg::ocr::max_unrecog_char_rate
{ static constexpr bool is_section = true; };

struct video
: cfg::video::break_interval
, cfg::video::codec_id
, cfg::video::ffmpeg_options
, cfg::video::capture_groupid
, cfg::video::png_interval
, cfg::video::frame_interval
, cfg::video::png_limit
, cfg::video::framerate
, cfg::video::capture_flags
, cfg::video::replay_path
, cfg::video::hash_path
, cfg::video::record_tmp_path
, cfg::video::record_path
, cfg::video::disable_keyboard_log
, cfg::video::disable_clipboard_log
, cfg::video::disable_file_system_log
, cfg::video::rt_display
, cfg::video::wrm_color_depth_selection_strategy
, cfg::video::wrm_compression_algorithm
, cfg::video::bogus_vlc_frame_rate
, cfg::video::notimestamp
, cfg::video::smart_video_cropping
, cfg::video::play_video_with_corrupted_bitmap
{ static constexpr bool is_section = true; };

struct capture
: cfg::capture::record_filebase
, cfg::capture::record_subdirectory
, cfg::capture::fdx_path
{ static constexpr bool is_section = true; };

struct crypto
: cfg::crypto::key0
, cfg::crypto::key1
{ static constexpr bool is_section = true; };

struct websocket
: cfg::websocket::listen_address
, cfg::websocket::enable_websocket
, cfg::websocket::use_tls
{ static constexpr bool is_section = true; };

struct debug
: cfg::debug::fake_target_ip
, cfg::debug::config
, cfg::debug::primary_orders
, cfg::debug::secondary_orders
, cfg::debug::bitmap_update
, cfg::debug::capture
, cfg::debug::auth
, cfg::debug::session
, cfg::debug::front
, cfg::debug::mod_rdp
, cfg::debug::mod_vnc
, cfg::debug::mod_internal
, cfg::debug::mod_xup
, cfg::debug::password
, cfg::debug::compression
, cfg::debug::cache
, cfg::debug::performance
, cfg::debug::pass_dialog_box
, cfg::debug::ocr
, cfg::debug::ffmpeg
{ static constexpr bool is_section = true; };

struct remote_program
: cfg::remote_program::allow_resize_hosted_desktop
{ static constexpr bool is_section = true; };

struct translation
: cfg::translation::password_en
, cfg::translation::password_fr
, cfg::translation::language
{ static constexpr bool is_section = true; };

struct internal_mod
: cfg::internal_mod::theme
{ static constexpr bool is_section = true; };

struct context
: cfg::context::psid
, cfg::context::auth_error_message
, cfg::context::selector_device_filter
, cfg::context::selector_group_filter
, cfg::context::selector_proto_filter
, cfg::context::target_password
, cfg::context::target_host
, cfg::context::target_str
, cfg::context::target_service
, cfg::context::target_protocol
, cfg::context::password
, cfg::context::nla_password_hash
, cfg::context::reporting
, cfg::context::auth_channel_answer
, cfg::context::auth_channel_target
, cfg::context::message
, cfg::context::rejected
, cfg::context::session_id
, cfg::context::real_target_device
, cfg::context::ticket
, cfg::context::comment
, cfg::context::duration
, cfg::context::waitinforeturn
, cfg::context::module
, cfg::context::proxy_opt
, cfg::context::pattern_kill
, cfg::context::pattern_notify
, cfg::context::opt_message
, cfg::context::login_message
, cfg::context::session_probe_outbound_connection_monitoring_rules
, cfg::context::session_probe_process_monitoring_rules
, cfg::context::session_probe_extra_system_processes
, cfg::context::session_probe_windows_of_these_applications_as_unidentified_input_field
, cfg::context::disconnect_reason
, cfg::context::ip_target
, cfg::context::auth_command
, cfg::context::auth_notify
, cfg::context::auth_notify_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_original_exe_or_file
, cfg::context::auth_command_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_working_dir
, cfg::context::auth_command_rail_exec_arguments
, cfg::context::auth_command_rail_exec_account
, cfg::context::auth_command_rail_exec_password
, cfg::context::session_probe_launch_error_message
, cfg::context::close_box_extra_message
, cfg::context::pm_response
, cfg::context::pm_request
, cfg::context::rd_shadow_userdata
, cfg::context::rd_shadow_type
, cfg::context::rd_shadow_invitation_error_message
, cfg::context::rd_shadow_invitation_id
, cfg::context::rd_shadow_invitation_addr
, cfg::context::smartcard_login
, cfg::context::selector_current_page
, cfg::context::selector_lines_per_page
, cfg::context::selector_number_of_pages
, cfg::context::target_port
, cfg::context::end_date_cnx
, cfg::context::duration_max
, cfg::context::formflag
, cfg::context::auth_notify_rail_exec_flags
, cfg::context::auth_command_rail_exec_exec_result
, cfg::context::auth_command_rail_exec_flags
, cfg::context::native_session_id
, cfg::context::rd_shadow_invitation_error_code
, cfg::context::rd_shadow_invitation_port
, cfg::context::opt_bpp
, cfg::context::opt_height
, cfg::context::opt_width
, cfg::context::selector
, cfg::context::accept_message
, cfg::context::display_message
, cfg::context::authenticated
, cfg::context::keepalive
, cfg::context::mode_console
, cfg::context::authentication_challenge
, cfg::context::showform
, cfg::context::forcemodule
, cfg::context::disconnect_reason_ack
, cfg::context::recording_started
, cfg::context::rt_ready
, cfg::context::perform_automatic_reconnection
, cfg::context::rail_disconnect_message_delay
, cfg::context::use_session_probe_to_launch_remote_program
, cfg::context::is_wabam
, cfg::context::rd_shadow_available
, cfg::context::rail_module_host_mod_is_active
{ static constexpr bool is_section = true; };

} // namespace cfg_section

namespace configs {
struct VariablesConfiguration
: cfg_section::globals
, cfg_section::session_log
, cfg_section::client
, cfg_section::mod_rdp
, cfg_section::mod_vnc
, cfg_section::metrics
, cfg_section::file_verification
, cfg_section::file_storage
, cfg_section::icap_server_down
, cfg_section::icap_server_up
, cfg_section::mod_replay
, cfg_section::ocr
, cfg_section::video
, cfg_section::capture
, cfg_section::crypto
, cfg_section::websocket
, cfg_section::debug
, cfg_section::remote_program
, cfg_section::translation
, cfg_section::internal_mod
, cfg_section::context
{};

using VariablesAclPack = Pack<
  cfg::globals::capture_chunk
, cfg::globals::nla_auth_user
, cfg::globals::auth_user
, cfg::globals::host
, cfg::globals::target
, cfg::globals::target_device
, cfg::globals::device_id
, cfg::globals::primary_user_id
, cfg::globals::target_user
, cfg::globals::target_application
, cfg::globals::target_application_account
, cfg::globals::target_application_password
, cfg::globals::inactivity_timeout
, cfg::globals::trace_type
, cfg::globals::is_rec
, cfg::globals::movie_path
, cfg::globals::unicode_keyboard_event_support
, cfg::globals::mod_recv_timeout
, cfg::session_log::keyboard_input_masking_level
, cfg::client::keyboard_layout
, cfg::client::disable_tsk_switch_shortcuts
, cfg::mod_rdp::disabled_orders
, cfg::mod_rdp::enable_nla
, cfg::mod_rdp::enable_kerberos
, cfg::mod_rdp::tls_min_level
, cfg::mod_rdp::tls_max_level
, cfg::mod_rdp::cipher_string
, cfg::mod_rdp::show_common_cipher_list
, cfg::mod_rdp::allow_channels
, cfg::mod_rdp::deny_channels
, cfg::mod_rdp::server_redirection_support
, cfg::mod_rdp::load_balance_info
, cfg::mod_rdp::bogus_sc_net_size
, cfg::mod_rdp::proxy_managed_drives
, cfg::mod_rdp::ignore_auth_channel
, cfg::mod_rdp::alternate_shell
, cfg::mod_rdp::shell_arguments
, cfg::mod_rdp::shell_working_directory
, cfg::mod_rdp::use_client_provided_alternate_shell
, cfg::mod_rdp::use_client_provided_remoteapp
, cfg::mod_rdp::use_native_remoteapp_capability
, cfg::mod_rdp::enable_session_probe
, cfg::mod_rdp::session_probe_use_clipboard_based_launcher
, cfg::mod_rdp::session_probe_enable_launch_mask
, cfg::mod_rdp::session_probe_on_launch_failure
, cfg::mod_rdp::session_probe_launch_timeout
, cfg::mod_rdp::session_probe_launch_fallback_timeout
, cfg::mod_rdp::session_probe_start_launch_timeout_timer_only_after_logon
, cfg::mod_rdp::session_probe_keepalive_timeout
, cfg::mod_rdp::session_probe_on_keepalive_timeout
, cfg::mod_rdp::session_probe_end_disconnected_session
, cfg::mod_rdp::session_probe_enable_log
, cfg::mod_rdp::session_probe_enable_log_rotation
, cfg::mod_rdp::session_probe_disconnected_application_limit
, cfg::mod_rdp::session_probe_disconnected_session_limit
, cfg::mod_rdp::session_probe_idle_session_limit
, cfg::mod_rdp::session_probe_clipboard_based_launcher_clipboard_initialization_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_start_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_long_delay
, cfg::mod_rdp::session_probe_clipboard_based_launcher_short_delay
, cfg::mod_rdp::session_probe_launcher_abort_delay
, cfg::mod_rdp::session_probe_enable_crash_dump
, cfg::mod_rdp::session_probe_handle_usage_limit
, cfg::mod_rdp::session_probe_memory_usage_limit
, cfg::mod_rdp::session_probe_end_of_session_check_delay_time
, cfg::mod_rdp::session_probe_ignore_ui_less_processes_during_end_of_session_check
, cfg::mod_rdp::session_probe_childless_window_as_unidentified_input_field
, cfg::mod_rdp::session_probe_disabled_features
, cfg::mod_rdp::enable_bestsafe_integration
, cfg::mod_rdp::session_probe_public_session
, cfg::mod_rdp::session_probe_on_account_manipulation
, cfg::mod_rdp::server_cert_store
, cfg::mod_rdp::server_cert_check
, cfg::mod_rdp::server_access_allowed_message
, cfg::mod_rdp::server_cert_create_message
, cfg::mod_rdp::server_cert_success_message
, cfg::mod_rdp::server_cert_failure_message
, cfg::mod_rdp::enable_rdpdr_data_analysis
, cfg::mod_rdp::wabam_uses_translated_remoteapp
, cfg::mod_rdp::enable_server_cert_external_validation
, cfg::mod_rdp::server_cert
, cfg::mod_rdp::server_cert_response
, cfg::mod_rdp::enable_remotefx
, cfg::mod_rdp::enable_restricted_admin_mode
, cfg::mod_rdp::force_smartcard_authentication
, cfg::mod_vnc::clipboard_up
, cfg::mod_vnc::clipboard_down
, cfg::mod_vnc::server_clipboard_encoding_type
, cfg::mod_vnc::bogus_clipboard_infinite_loop
, cfg::mod_vnc::server_is_macos
, cfg::mod_vnc::server_unix_alt
, cfg::mod_vnc::support_cursor_pseudo_encoding
, cfg::file_verification::enable_up
, cfg::file_verification::enable_down
, cfg::file_verification::clipboard_text_up
, cfg::file_verification::clipboard_text_down
, cfg::file_verification::log_if_accepted
, cfg::file_storage::store_file
, cfg::mod_replay::replay_on_loop
, cfg::video::hash_path
, cfg::video::record_tmp_path
, cfg::video::record_path
, cfg::video::disable_keyboard_log
, cfg::video::rt_display
, cfg::capture::record_filebase
, cfg::capture::record_subdirectory
, cfg::capture::fdx_path
, cfg::crypto::key0
, cfg::crypto::key1
, cfg::remote_program::allow_resize_hosted_desktop
, cfg::translation::language
, cfg::translation::password_en
, cfg::translation::password_fr
, cfg::context::psid
, cfg::context::opt_bpp
, cfg::context::opt_height
, cfg::context::opt_width
, cfg::context::selector
, cfg::context::selector_current_page
, cfg::context::selector_device_filter
, cfg::context::selector_group_filter
, cfg::context::selector_proto_filter
, cfg::context::selector_lines_per_page
, cfg::context::selector_number_of_pages
, cfg::context::target_password
, cfg::context::target_host
, cfg::context::target_str
, cfg::context::target_service
, cfg::context::target_port
, cfg::context::target_protocol
, cfg::context::password
, cfg::context::nla_password_hash
, cfg::context::reporting
, cfg::context::auth_channel_answer
, cfg::context::auth_channel_target
, cfg::context::message
, cfg::context::accept_message
, cfg::context::display_message
, cfg::context::rejected
, cfg::context::authenticated
, cfg::context::keepalive
, cfg::context::session_id
, cfg::context::end_date_cnx
, cfg::context::mode_console
, cfg::context::real_target_device
, cfg::context::authentication_challenge
, cfg::context::ticket
, cfg::context::comment
, cfg::context::duration
, cfg::context::duration_max
, cfg::context::waitinforeturn
, cfg::context::showform
, cfg::context::formflag
, cfg::context::module
, cfg::context::forcemodule
, cfg::context::proxy_opt
, cfg::context::pattern_kill
, cfg::context::pattern_notify
, cfg::context::opt_message
, cfg::context::login_message
, cfg::context::session_probe_outbound_connection_monitoring_rules
, cfg::context::session_probe_process_monitoring_rules
, cfg::context::session_probe_extra_system_processes
, cfg::context::session_probe_windows_of_these_applications_as_unidentified_input_field
, cfg::context::disconnect_reason
, cfg::context::disconnect_reason_ack
, cfg::context::recording_started
, cfg::context::rt_ready
, cfg::context::auth_command
, cfg::context::auth_notify
, cfg::context::auth_notify_rail_exec_flags
, cfg::context::auth_notify_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_exec_result
, cfg::context::auth_command_rail_exec_flags
, cfg::context::auth_command_rail_exec_original_exe_or_file
, cfg::context::auth_command_rail_exec_exe_or_file
, cfg::context::auth_command_rail_exec_working_dir
, cfg::context::auth_command_rail_exec_arguments
, cfg::context::auth_command_rail_exec_account
, cfg::context::auth_command_rail_exec_password
, cfg::context::rail_disconnect_message_delay
, cfg::context::use_session_probe_to_launch_remote_program
, cfg::context::session_probe_launch_error_message
, cfg::context::is_wabam
, cfg::context::pm_response
, cfg::context::pm_request
, cfg::context::native_session_id
, cfg::context::rd_shadow_available
, cfg::context::rd_shadow_userdata
, cfg::context::rd_shadow_type
, cfg::context::rd_shadow_invitation_error_code
, cfg::context::rd_shadow_invitation_error_message
, cfg::context::rd_shadow_invitation_id
, cfg::context::rd_shadow_invitation_addr
, cfg::context::rd_shadow_invitation_port
, cfg::context::smartcard_login
>;


struct BitFlags {
  uint64_t bits_[4];
  bool operator()(unsigned i) const noexcept { return bits_[i/64] & (uint64_t{1} << (i%64)); }
};

constexpr BitFlags is_loggable{{
  0b1111111111111111111111111111111111111111111111111111011111111111
, 0b1110111111111111111001111111111111111111111111111111111111111111
, 0b1111111111110111111111111111111111111111111111111111111111011011
, 0b0000000000000000000000000000000000000000000000000000000000001111
}};
constexpr BitFlags is_unloggable_if_value_with_password{{
  0b0000000000000000000000000000000000000000000000000000000000000000
, 0b0000000000000000000000000000000000000000000000000000000000000000
, 0b0000000000000000000000000000000000000000000000000000000000100000
, 0b0000000000000000000000000000000000000000000000000000000000000000
}};
} // namespace configs
